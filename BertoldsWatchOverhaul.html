<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Bertold's Watch</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #2c1f28;
            color: #e0dacd;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Align to top for mobile */
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
            padding-top: 1rem; /* Add some padding at the top */
        }
        #gameCanvas {
            background-color: #1a1118;
            border: 2px solid #5a3e4a;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            cursor: crosshair;
            display: block; /* Important for scaling */
            max-width: 100%; /* Ensure it doesn't overflow container */
            /* Aspect ratio will be maintained by JS */
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem; /* Reduced padding for mobile */
            background-color: #3c2f38;
            border-radius: 12px;
            box-shadow: 0 0 30px rgba(0,0,0,0.7);
            width: 95%; /* Max width for game container */
            max-width: 800px; /* Max width for larger screens */
        }
        .ui-panel {
            background-color: rgba(40, 30, 38, 0.8);
            padding: 0.25rem 1rem;
            border-radius: 8px;
            border: 1px solid #5a3e4a;
            text-align: center;
            min-width: 300px;
            font-size: 0.85rem;
        }
        .ui-panel > div {
            margin-bottom: 0.05rem;
            line-height: 1.2;
        }
        .consumable-ui {
            display: inline-block;
            margin: 0 5px;
        }
        .button, .settings-button {
            background-color: #7a5e6a;
            color: #e0dacd;
            border: 2px solid #5a3e4a;
            padding: 0.6rem 1.2rem;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.1s;
            box-shadow: 0 3px #4a2e3a;
            font-size: 0.9rem;
            margin: 0.25rem;
        }
        .button:hover, .settings-button:hover {
            background-color: #8a6e7a;
        }
        .button:active, .settings-button:active {
            transform: translateY(1px);
            box-shadow: 0 2px #4a2e3a;
        }
        .settings-button.active {
            background-color: #9a7e8a;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
        }
        .pixel-art-font {
            font-family: 'Courier New', Courier, monospace;
            font-size: 1.1rem;
        }
        #messageOverlay, .cutscene-text-overlay {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(26, 17, 24, 0.85);
            color: #e0dacd; padding: 10px 15px; border-radius: 8px;
            border: 2px solid #5a3e4a; text-align: center;
            z-index: 10; font-size: 1.1em;
            display: none;
            width: 80%;
            max-width: 500px;
        }
        #messageOverlay { top: 50%; transform: translate(-50%, -50%);}
        .cutscene-text-overlay { bottom: 15%; }

        .tooltip {
            position: fixed;
            background-color: rgba(20,10,18,0.95);
            border: 1px solid #7a5e6a; color: #e0dacd; padding: 8px;
            border-radius: 6px; font-size: 0.85em;
            z-index: 1000;
            pointer-events: none; white-space: pre-wrap; max-width: 220px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div id="uiPanel" class="ui-panel mb-2">
            <div id="scoreDisplay" class="pixel-art-font">Score: 0</div>
            <div id="silverDisplay" class="pixel-art-font">Silver: 0</div>
            <div id="ammoDisplay" class="pixel-art-font">Bolts: 10/10</div>
            <div id="healthDisplay" class="pixel-art-font">Tower Integrity: 100%</div>
            <div id="waveDisplay" class="pixel-art-font">Wave: 1</div>
            <div id="reloadIndicator" class="pixel-art-font" style="color: #f7ca18; display: none;">Reloading...</div>
            <div id="consumablesDisplay" class="mt-1" style="width:100%; text-align:center;">
                <span class="consumable-ui">Potions(H): <span id="healthPotionCount">0</span></span>
                <span class="consumable-ui">Fireballs(F): <span id="fireballScrollCount">0</span></span>
                <span class="consumable-ui">Freezes(G): <span id="freezeScrollCount">0</span></span>
                <span class="consumable-ui">Alch.Fire(O): <span id="oilFlaskCount">0</span></span>
            </div>
        </div>

        <div style="position: relative; width: 100%;">
            <canvas id="gameCanvas"></canvas>
            <div id="messageOverlay" class="pixel-art-font"></div>
            <div id="cutsceneTextOverlay" class="cutscene-text-overlay pixel-art-font"></div>
            <div id="tooltip" class="tooltip" style="display: none;"></div>
        </div>

        <div id="controlsPanel" class="mt-2 flex flex-wrap justify-center gap-2">
            </div>
    </div>

    <script>
        // --- DOM Elements ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const silverDisplay = document.getElementById('silverDisplay');
        const ammoDisplay = document.getElementById('ammoDisplay');
        const healthDisplay = document.getElementById('healthDisplay');
        const waveDisplay = document.getElementById('waveDisplay');
        const reloadIndicator = document.getElementById('reloadIndicator');
        const controlsPanel = document.getElementById('controlsPanel');
        const messageOverlay = document.getElementById('messageOverlay');
        const cutsceneTextOverlay = document.getElementById('cutsceneTextOverlay');
        const tooltipElement = document.getElementById('tooltip');
        const healthPotionCountDisplay = document.getElementById('healthPotionCount');
        const fireballScrollCountDisplay = document.getElementById('fireballScrollCount');
        const freezeScrollCountDisplay = document.getElementById('freezeScrollCount');
        const oilFlaskCountDisplay = document.getElementById('oilFlaskCount');


        // --- Game Configuration ---
        const PIXEL_SCALE = 2;
        const BASE_CANVAS_WIDTH = 400;
        const BASE_CANVAS_HEIGHT = 300;
        const MAX_WAVES = 10;

        canvas.width = BASE_CANVAS_WIDTH * PIXEL_SCALE;
        canvas.height = BASE_CANVAS_HEIGHT * PIXEL_SCALE;
        ctx.imageSmoothingEnabled = false;

        // --- Game Settings ---
        let soundEnabled = true;
        let difficulty = 'Normal';
        const difficultySettings = {
            Easy:   { healthFactor: 0.7, speedFactor: 0.8, countFactor: 0.75, silverFactor: 1.2, bossHealthFactor: 0.7 },
            Normal: { healthFactor: 1.0, speedFactor: 1.0, countFactor: 1.0,  silverFactor: 1.0, bossHealthFactor: 1.0 },
            Nightmare:{ healthFactor: 1.5, speedFactor: 1.2, countFactor: 1.3,  silverFactor: 0.8, bossHealthFactor: 1.4 }
        };


        // --- Game State Variables ---
        let gameState = 'START_SCREEN';
        let score = 0, silver = 50, wave = 1, towerHealth = 100, maxTowerHealth = 100;
        let enemies = [], bolts = [], boss = null, ghoulBolts = [], activeOilSpills = [], activeFireballs = [], bossProjectiles = [];
        let mouseX = canvas.width / 2, mouseY = canvas.height - 50 * PIXEL_SCALE;
        let lastTime = 0, gameLoopRequestId;
        let frameCount = 0;
        let enemiesFrozen = false; let freezeTimer = 0;
        let cutsceneStage = 0;
        let cutsceneTimer = 0;
        const CUTSCENE_FRAME_DURATION = 4000; // Duration for each cutscene frame in ms
        let parallaxOffsetX = 0;
        let cloudLayer1 = [], cloudLayer2 = [];
        let weatherEffect = null;
        let weatherParticles = [];

        // --- Player State ---
        const player = {
            x: canvas.width / 2, y: canvas.height - 20 * PIXEL_SCALE,
            currentAmmo: 0, isReloading: false, reloadTimer: 0, equippedCrossbow: null,
            hasFlamingArrowsUpgrade: false, hasPiercingBoltsUpgrade: false,
            hasStakes: false, towerReinforced: false,
            healthPotions: 0, fireballScrolls: 0, freezeScrolls: 0, oilFlasks: 0
        };

        // --- Asset Definitions ---
        // Object to store loaded images (cutscenes, backgrounds, etc.)
        const loadedImages = {};
        let allAssetsLoaded = false; // Flag to check if all essential images are loaded

        // Cutscene Frame Data - Updated to use image files
        const introCutsceneFrames = [
            { imageKey: 'intro_towerscene', imageSrc: 'assets/towerscene.jpg', text: "The borderlands have grown restless. Whispers of ancient evils stir in the shadowed forests." },
            { imageKey: 'intro_interiorscene', imageSrc: 'assets/interiorscene.jpg', text: "Only Bertold, its lone guardian, remains vigilant." },
            { imageKey: 'intro_defencescene', imageSrc: 'assets/defencescene.jpg', text: "Tonight, the whispers become screams. The Gh큰ls are coming." },
            { imageKey: 'intro_bertold_ready', imageSrc: 'assets/interiorscene.jpg', text: "He checks his crossbow. The Watch must not fall." } // Reusing interiorscene for "ready"
        ];

        const victoryCutsceneFrames = [
            { imageKey: 'victory_defencescene', imageSrc: 'assets/defencescene.jpg', text: "With a final, unholy shriek, Jer'Ghuul dissolves into nothingness." },
            { imageKey: 'victory_interiorscene', imageSrc: 'assets/interiorscene.jpg', text: "Bertold lowers his crossbow, the silence of the dawn almost deafening." },
            { imageKey: 'victory_towerview', imageSrc: 'assets/towerview.jpg', text: "The Watch is safe... for now. But the darkness always lingers." }
        ];


        const crossbowDefinitions = [
            { id: 'peasant', name: "Peasant's Crossbow", rarity: "Common", color: "#DDDDDD", damage: 10, ammoCapacity: 10, reloadTime: 2.5, boltSpeed: 300, cost: 0, description: "A basic, reliable crossbow." , wood: '#6b4f3a', metal: '#6c7a89'},
            { id: 'hunter', name: "Hunter's Light Crossbow", rarity: "Uncommon", color: "#1EFF00", damage: 12, ammoCapacity: 12, reloadTime: 2.2, boltSpeed: 330, cost: 100, description: "Quick reload, decent punch." , wood: '#7f5f4a', metal: '#7c8a99'},
            { id: 'guard', name: "Guardman's Heavy Crossbow", rarity: "Uncommon", color: "#1EFF00", damage: 15, ammoCapacity: 8, reloadTime: 3.0, boltSpeed: 350, cost: 120, description: "Hits harder, slower reload.", wood: '#5b3f2a', metal: '#5c6a79' },
            { id: 'ranger', name: "Ranger's Swiftbow", rarity: "Uncommon", color: "#1EFF00", damage: 13, ammoCapacity: 14, reloadTime: 2.1, boltSpeed: 340, cost: 110, description: "Fast and light, for skirmishers.", wood: '#8a6f5a', metal: '#808c99'},
            { id: 'marksman', name: "Marksman's Arbalest", rarity: "Rare", color: "#0070DD", damage: 20, ammoCapacity: 15, reloadTime: 2.7, boltSpeed: 380, cost: 300, description: "Superior range and stopping power.", wood: '#6b4f3a', metal: '#8c9aaf' },
            { id: 'sniper', name: "Eagle Eye Repeater", rarity: "Rare", color: "#0070DD", damage: 18, ammoCapacity: 18, reloadTime: 2.4, boltSpeed: 360, cost: 320, description: "Larger quiver for sustained fire.", wood: '#7f5f4a', metal: '#9cb0c1' },
            { id: 'knight', name: "Knight's War Crossbow", rarity: "Rare", color: "#0070DD", damage: 22, ammoCapacity: 12, reloadTime: 2.9, boltSpeed: 370, cost: 350, description: "A weapon of war, built for impact.", wood: '#503020', metal: '#7c8aab'},
            { id: 'artificer', name: "Artificer's Doomstring", rarity: "Epic", color: "#A335EE", damage: 30, ammoCapacity: 12, reloadTime: 3.0, boltSpeed: 420, cost: 500, description: "Fires two bolts per shot. Devastating force.", wood: '#402010', metal: '#a0b0d0', mechanic: 'multishot_2'},
            { id: 'ghoulbane', name: "Gh큰lBane Siegebow", rarity: "Epic", color: "#A335EE", damage: 25, ammoCapacity: 20, reloadTime: 3.5, boltSpeed: 400, cost: 550, description: "Enchanted against the undead. Fires two bolts.", wood: '#503020', metal: '#b0c0e0', mechanic: 'multishot_2'},
            { id: 'shadowstrike', name: "Shadowstrike Repeater", rarity: "Epic", color: "#A335EE", damage: 28, ammoCapacity: 16, reloadTime: 2.8, boltSpeed: 430, cost: 600, description: "Fires two shadowy bolts.", wood: '#2a2a3a', metal: '#605070', mechanic: 'multishot_2'},
            { id: 'celestial_boltthrower', name: "Celestial Boltthrower", rarity: "Legendary", color: "#FF8C00", damage: 45, ammoCapacity: 15, reloadTime: 2.8, boltSpeed: 500, cost: 1000, description: "Fires three bolts of pure starlight. Cosmic power." , wood: '#100820', metal: '#E0E0FF', mechanic: 'multishot_3_flaming'},
            { id: 'stormcaller', name: "Stormcaller Greatbow", rarity: "Legendary", color: "#FF8C00", damage: 40, ammoCapacity: 18, reloadTime: 3.0, boltSpeed: 480, cost: 1200, description: "Unleashes three crackling lightning bolts." , wood: '#304050', metal: '#A0B8D0', mechanic: 'multishot_3_flaming'}
        ];
        let ownedCrossbowIds = ['peasant'];

        const bertoldColors = {
            armor: '#6c7a89', cloth: '#A52A2A', trim: '#f7ca18',
            wood: '#6b4f3a', string: '#c8c8c8', skin: '#e0c0a0',
            hair: '#5D4037', eye: '#222222', boots: '#4a3b32',
            belt: '#795548', cape: '#8B0000', helmet_metal: '#555555', helmet_trim: '#444444'
        };
        const ghulColors = { skin: '#a2b9a0', eyes: '#c0392b', rags: '#4a4a4a', projectile: '#50C878', boss_projectile: '#4B0082' };

        const commonEnvironmentColors = {
            tower_stone: '#6a6a6a', tower_stone_darker: '#474747', tower_stone_highlight: '#7c7c7c',
            tower_wood: '#6b4f3a', tower_wood_dark: '#4a3220', path: '#706151', path_darker: '#504131',
            fire_orange: '#FFA500', fire_red: '#FF4500', fire_yellow: '#FFD700',
            candle_flame: '#FFD700', candle_light: 'rgba(255,223,186,0.2)',
            lantern_metal: '#4a4a4a', lantern_glass: 'rgba(255, 240, 200, 0.6)', lantern_glow: 'rgba(255, 200, 100, 0.3)',
            mountain_base: '#455A64', mountain_mid: '#607D8B', mountain_peak: '#B0BEC5',
            mountain_base_day: '#546E7A', mountain_mid_day: '#6D838F', mountain_peak_day: '#B8C2CC',
            potion_red: '#E53935', potion_blue: '#1E88E5', potion_green: '#43A047', potion_purple: '#8E24AA',
            book_cover_brown: '#8D6E63', book_cover_red: '#D32F2F', book_cover_blue: '#1976D2', book_pages: '#FFFDE7',
            pavise_wood: '#8B4513', pavise_cross: '#FFFFFF', pavise_border: '#4A2E0E',
            cloud_light: 'rgba(220, 220, 230, 0.6)', cloud_dark: 'rgba(180, 180, 190, 0.5)'
        };

        const nightEnvironmentColors = {
            sky_gradient_top: '#0a080c', sky_gradient_bottom: '#1a1118',
            moon: '#FFFFFF', moon_glow: 'rgba(220, 220, 255, 0.15)',
            forest_far: '#22301f', forest_mid: '#2f402f', forest_near: '#3f503f',
            castle_silhouette: '#302838', castle_tower: '#403848', castle_roof: '#201828', castle_battlement: '#383040',
            castle_light: commonEnvironmentColors.fire_yellow,
            mountain_base: commonEnvironmentColors.mountain_base, mountain_mid: commonEnvironmentColors.mountain_mid, mountain_peak: commonEnvironmentColors.mountain_peak,
        };
        const dayEnvironmentColors = {
            sky_gradient_top: '#A0B0C0', sky_gradient_bottom: '#C0D0E0',
            sun: '#FFEEAA', sun_rays: 'rgba(255, 255, 220, 0.08)',
            forest_far: '#3D5A4A', forest_mid: '#4A6D5A', forest_near: '#5A7D6A',
            castle_silhouette: '#504850', castle_tower: '#605860', castle_roof: '#403840', castle_battlement: '#585058',
            castle_light: 'rgba(255,255,100,0.3)',
            mountain_base: commonEnvironmentColors.mountain_base_day, mountain_mid: commonEnvironmentColors.mountain_mid_day, mountain_peak: commonEnvironmentColors.mountain_peak_day,
        };

        let interiorDetails = {};
        let shopItems = [], shopItemRects = [], shopBackgroundDetails = [];
        let defenseSceneElementsGenerated = false;
        let defenseStars = [], farForestTrees = [], midForestTrees = [], distantCastles = [], parapetStones = [], mountains = [], pathTextureElements = [], defensePaviseShields = [];
        let totalEnemiesForWave = 0, enemiesToSpawnThisWave = 0, lastEnemySpawnTime = 0;
        let lastMessage = "";
        let fireFlickerState = { phase: 0, lastPhaseChange: 0, interval: 200 };
        const BOLT_SPREAD_ANGLE = 0.1;

        // --- Function Definitions ---

        // Function to preload all necessary images
        function preloadAllImages(callback) {
            let imagesToLoad = 0;
            const allImageInfo = [];
            const uniqueImageKeys = new Set();

            // Add cutscene images
            [...introCutsceneFrames, ...victoryCutsceneFrames].forEach(frame => {
                if (frame.imageSrc && !uniqueImageKeys.has(frame.imageKey)) {
                    allImageInfo.push({ key: frame.imageKey, src: frame.imageSrc });
                    uniqueImageKeys.add(frame.imageKey);
                }
            });

            // Add start screen background image
            if (!uniqueImageKeys.has('start_screen_bg')) {
                allImageInfo.push({ key: 'start_screen_bg', src: 'assets/towerscene.jpg' });
                uniqueImageKeys.add('start_screen_bg');
            }
            // Add any other specific images here if needed later

            allImageInfo.forEach(info => {
                if (!loadedImages[info.key]) { // Check if not already loaded/being loaded by this key
                    imagesToLoad++;
                }
            });

            if (imagesToLoad === 0) {
                allAssetsLoaded = true;
                if (callback) callback();
                return;
            }

            let imagesLoadedCount = 0;
            allImageInfo.forEach(info => {
                if (!loadedImages[info.key]) {
                    const img = new Image();
                    img.src = info.src;
                    loadedImages[info.key] = img; // Store image object immediately
                    img.onload = () => {
                        imagesLoadedCount++;
                        console.log(`Successfully loaded image: ${info.src} (for key: ${info.key})`);
                        if (imagesLoadedCount === imagesToLoad) {
                            allAssetsLoaded = true;
                            console.log("All specified images have been processed (loaded or errored).");
                            if (callback) callback();
                        }
                    };
                    img.onerror = () => {
                        imagesLoadedCount++;
                        // Log a more detailed error message to help user debug file paths
                        console.error(`Failed to load image: ${info.src} (for key: ${info.key}). Please ensure the file exists at this path relative to your HTML file and that the 'assets' folder is correctly placed.`);
                        // Store a placeholder or error object
                        loadedImages[info.key] = {
                            complete: true, // Mark as processed
                            error: true,
                            srcPath: info.src, // Store the problematic path
                            naturalWidth: canvas.width, // Dummy dimensions for fallback
                            naturalHeight: canvas.height
                        };
                        if (imagesLoadedCount === imagesToLoad) {
                            allAssetsLoaded = true;
                            console.warn("Some images failed to load. The game will proceed with fallbacks for missing images.");
                            if (callback) callback();
                        }
                    };
                }
            });
        }


        function playSound(soundName) { if(soundEnabled) { /* console.log(`Sound: ${soundName}`); */ } }
        function equipCrossbow(crossbowId) { const crossbow = crossbowDefinitions.find(c => c.id === crossbowId); if (crossbow) { player.equippedCrossbow = crossbow; player.currentAmmo = crossbow.ammoCapacity; updateAmmoDisplay(); } }
        function generateDefenseStars(count) { defenseStars = []; for (let i = 0; i < count; i++) { defenseStars.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height * 0.45, size: PIXEL_SCALE * (Math.random() > 0.6 ? (Math.random() > 0.85 ? 2 : 1.5) : 1), opacity: 0.5 + Math.random() * 0.5 }); } }
        function generateFarForestTrees() { farForestTrees = []; for (let i = 0; i < canvas.width / (10 * PIXEL_SCALE); i++) { farForestTrees.push({ x: i * 10 * PIXEL_SCALE + (Math.random() * 3 - 1.5) * PIXEL_SCALE, baseY: canvas.height * 0.65, height: (20 + Math.random() * 15) * PIXEL_SCALE, width: (10 + Math.random() * 8) * PIXEL_SCALE, type: Math.random() > 0.6 ? 'pine' : 'deciduous' }); } }
        function generateMidForestTrees() { midForestTrees = []; for (let i = 0; i < canvas.width / (18 * PIXEL_SCALE); i++) { midForestTrees.push({ x: i * 18 * PIXEL_SCALE + (Math.random() * 5 - 2.5) * PIXEL_SCALE, baseY: canvas.height * 0.6 + 35 * PIXEL_SCALE, height: (30 + Math.random() * 20) * PIXEL_SCALE, width: (15 + Math.random() * 12) * PIXEL_SCALE, type: Math.random() > 0.5 ? 'pine' : 'deciduous' }); } }
        function generateDistantCastles() { distantCastles = []; const castleCount = Math.floor(Math.random() * 2) + 1; for (let i = 0; i < castleCount; i++) { const castleWidth = (40 + Math.random() * 30) * PIXEL_SCALE; const castleHeight = (50 + Math.random() * 40) * PIXEL_SCALE; const castleX = Math.random() * (canvas.width - castleWidth * 1.5) + castleWidth * 0.25; const castleY = canvas.height * 0.50 - castleHeight - (Math.random() * 5 * PIXEL_SCALE); const numTowers = Math.floor(Math.random() * 3) + 2; const towers = []; for(let j=0; j < numTowers; j++) { towers.push({ xOffset: (j * castleWidth / numTowers) + (Math.random() * castleWidth / (numTowers*2) - castleWidth / (numTowers*4)), width: (castleWidth / numTowers) * (0.5 + Math.random()*0.4), height: castleHeight * (0.6 + Math.random()*0.3), roofType: Math.random() > 0.4 ? 'conical' : (Math.random() > 0.5 ? 'flat' : 'domed') }); } const lights = []; for(let k=0; k<7; k++){ if(Math.random() > 0.3) { lights.push({ x: castleX + (Math.random()*0.6 + 0.1)*castleWidth, y: castleY + (Math.random()*0.5 + 0.2)*castleHeight, w: PIXEL_SCALE * (Math.random() > 0.5 ? 1.5 : 1), h: PIXEL_SCALE * (Math.random()*1 + 1) }); } } distantCastles.push({ x: castleX, y: castleY, width: castleWidth, height: castleHeight, towers: towers, lights: lights }); } }
        function generateParapetWall() { parapetStones = []; const parapetHeight = 30 * PIXEL_SCALE; const stoneSize = 5 * PIXEL_SCALE; for (let y = 0; y < parapetHeight; y += stoneSize) { for (let x = 0; x < canvas.width; x += stoneSize) { const colorRand = Math.random(); let color; if (colorRand < 0.5) color = commonEnvironmentColors.tower_stone; else if (colorRand < 0.85) color = commonEnvironmentColors.tower_stone_darker; else color = commonEnvironmentColors.tower_stone_highlight; parapetStones.push({ x: x + (Math.random() - 0.5) * PIXEL_SCALE * 0.5, y: canvas.height - parapetHeight + y + (Math.random() - 0.5) * PIXEL_SCALE * 0.5, sizeW: stoneSize + (Math.random()-0.5)*PIXEL_SCALE*2, sizeH: stoneSize + (Math.random()-0.5)*PIXEL_SCALE, color: color }); } } }
        function generateMountains() { mountains = []; const mountainCount = Math.floor(Math.random() * 4) + 3; const mountainMaxHeight = canvas.height * 0.4; const mountainMinHeight = canvas.height * 0.2; for (let i = 0; i < mountainCount; i++) { const mountainWidth = (70 + Math.random() * 100) * PIXEL_SCALE; const mountainHeight = Math.random() * (mountainMaxHeight - mountainMinHeight) + mountainMinHeight; const mountainX = (Math.random() * (canvas.width + mountainWidth*0.5)) - mountainWidth*0.25; const mountainY = canvas.height * 0.50 - mountainHeight; const individualPeaks = []; const peakCount = 5 + Math.floor(Math.random() * 5); for (let j = 0; j < peakCount; j++) { const peakXRatio = (j / peakCount) + (Math.sin(Math.random() * 10 + j) * 0.1 / peakCount); const peakBaseYRatio = 0.15 + Math.random() * 0.25; const peakHeightRatio = 0.1 + Math.random() * 0.20; const peakYOffsetValue = Math.cos(Math.random() * 15 + j * 2) * mountainHeight * 0.05; individualPeaks.push({ xRatio: peakXRatio, baseYRatio: peakBaseYRatio, heightRatio: peakHeightRatio, yOffset: peakYOffsetValue }); } mountains.push({ x: mountainX, y: mountainY, width: mountainWidth, height: mountainHeight, peaks: individualPeaks }); } mountains.sort((a,b) => (a.y + a.height) - (b.y + b.height)); }
        function generatePathTexture() { pathTextureElements = []; for (let p = 0; p < 30; p++) { pathTextureElements.push({ x: canvas.width * (0.3 + Math.random() * 0.4), y: canvas.height * (0.75 + Math.random() * 0.25), w: PIXEL_SCALE * (Math.random() * 2 + 1), h: PIXEL_SCALE * (Math.random() * 1.5 + 1), color: Math.random() > 0.5 ? commonEnvironmentColors.path : commonEnvironmentColors.path_darker }); } }
        function generateShopBackgroundDetails() {
            shopBackgroundDetails = [];
            const shelfHeight = 10 * PIXEL_SCALE;
            const shelfYPositions = [canvas.height * 0.25, canvas.height * 0.50, canvas.height * 0.75];

            shelfYPositions.forEach(shelfY => {
                shopBackgroundDetails.push({type: 'shelf', x: 10 * PIXEL_SCALE, y: shelfY, width: canvas.width - 20 * PIXEL_SCALE, height: shelfHeight});
                ctx.fillStyle = commonEnvironmentColors.tower_wood;
                ctx.fillRect(15 * PIXEL_SCALE, shelfY + shelfHeight, 5*PIXEL_SCALE, 12*PIXEL_SCALE);
                ctx.fillRect(canvas.width - 20 * PIXEL_SCALE, shelfY + shelfHeight, 5*PIXEL_SCALE, 12*PIXEL_SCALE);

                for(let i=0; i < 6; i++) {
                    const itemTypeRand = Math.random();
                    const itemX = (25 + i * (BASE_CANVAS_WIDTH-50)/6 + Math.random()*8 - 4) * PIXEL_SCALE;
                    const itemYBase = shelfY - 2*PIXEL_SCALE;

                    if (itemTypeRand < 0.25) {
                        shopBackgroundDetails.push({type: 'bg_crossbow', x: itemX, y: itemYBase - 18 * PIXEL_SCALE, width: 25*PIXEL_SCALE, height: 10*PIXEL_SCALE, angle: (Math.random()-0.5)*0.2});
                    } else if (itemTypeRand < 0.45) {
                        shopBackgroundDetails.push({type: 'bg_bolts', x: itemX, y: itemYBase - 12 * PIXEL_SCALE, count: Math.floor(Math.random()*4)+4});
                    } else if (itemTypeRand < 0.7) {
                        const bookCount = Math.floor(Math.random()*3)+2;
                        for(let b=0; b<bookCount; b++){
                             shopBackgroundDetails.push({type: 'bg_book', x: itemX + b*4*PIXEL_SCALE, y: itemYBase - 10*PIXEL_SCALE - b*PIXEL_SCALE, width: 7*PIXEL_SCALE, height:10*PIXEL_SCALE, color: [commonEnvironmentColors.book_cover_brown, commonEnvironmentColors.book_cover_red, commonEnvironmentColors.book_cover_blue][Math.floor(Math.random()*3)]});
                        }
                    } else if (itemTypeRand < 0.85) {
                        shopBackgroundDetails.push({type: 'bg_potion', x: itemX, y: itemYBase - 12*PIXEL_SCALE, radius: 4*PIXEL_SCALE, color: [commonEnvironmentColors.potion_red, commonEnvironmentColors.potion_blue, commonEnvironmentColors.potion_green, commonEnvironmentColors.potion_purple][Math.floor(Math.random()*4)]});
                    } else {
                         shopBackgroundDetails.push({type: 'bg_helmet', x: itemX, y: itemYBase - 10*PIXEL_SCALE, radius: 6*PIXEL_SCALE });
                    }
                }
            });
        }
        function generateDefensePaviseShields() {
            defensePaviseShields = [];
            const parapetHeight = 30 * PIXEL_SCALE;
            defensePaviseShields.push({ x: 50 * PIXEL_SCALE, y: canvas.height - parapetHeight - 20 * PIXEL_SCALE, width: 15 * PIXEL_SCALE, height: 25 * PIXEL_SCALE, angle: -0.1 });
            defensePaviseShields.push({ x: canvas.width - 65 * PIXEL_SCALE, y: canvas.height - parapetHeight - 20 * PIXEL_SCALE, width: 15 * PIXEL_SCALE, height: 25 * PIXEL_SCALE, angle: 0.1 });
        }


        function gameLoop(timestamp) { const deltaTime = (timestamp - lastTime) / 1000; lastTime = timestamp; frameCount++; update(deltaTime); draw(); if (gameState === 'DEFENDING' || gameState === 'BOSS_WAVE' || (gameState === 'TOWER_INTERIOR' && !player.isReloading) || gameState === 'INTRO_CUTSCENE' || gameState === 'VICTORY_CUTSCENE') { gameLoopRequestId = requestAnimationFrame(gameLoop); } }

        function update(deltaTime) {
            if (gameState === 'INTRO_CUTSCENE' || gameState === 'VICTORY_CUTSCENE') {
                if (Date.now() - cutsceneTimer > CUTSCENE_FRAME_DURATION) {
                    cutsceneStage++;
                    cutsceneTimer = Date.now();
                    playSound('cutscene_next');
                    if (gameState === 'INTRO_CUTSCENE' && cutsceneStage >= introCutsceneFrames.length) {
                        gameState = 'TOWER_INTERIOR';
                        cutsceneTextOverlay.style.display = 'none';
                        generateInteriorDetails();
                        updateControls();
                        let interiorAnimId; function animateInteriorLoop() { if (gameState !== 'TOWER_INTERIOR') { cancelAnimationFrame(interiorAnimId); return; } draw(); interiorAnimId = requestAnimationFrame(animateInteriorLoop); } lastTime = performance.now(); animateInteriorLoop();
                    } else if (gameState === 'VICTORY_CUTSCENE' && cutsceneStage >= victoryCutsceneFrames.length) {
                        gameState = 'VICTORY';
                        cutsceneTextOverlay.style.display = 'none';
                        updateControls();
                    }
                    draw(); // Redraw immediately after stage change
                }
                return; // Skip other updates during cutscenes
            }


            if (player.isReloading) {
                player.reloadTimer -= deltaTime;
                if (player.reloadTimer <= 0) { player.isReloading = false; player.currentAmmo = player.equippedCrossbow.ammoCapacity; updateAmmoDisplay(); reloadIndicator.style.display = 'none'; playSound('reload_finish');}
            }
            if (enemiesFrozen) {
                freezeTimer -= deltaTime;
                if (freezeTimer <= 0) {
                    enemiesFrozen = false;
                    playSound('unfreeze');
                }
            }
            activeFireballs.forEach((fb, index) => {
                fb.duration -= deltaTime;
                fb.radius += fb.expansionRate * deltaTime;
                const targets = gameState === 'BOSS_WAVE' && boss ? [boss] : enemies;
                targets.forEach(target => {
                    if (!target.hitByFireballThisFrame && Math.hypot(target.x + target.width/2 - fb.x, target.y + target.height/2 - fb.y) < fb.radius) {
                        target.health -= 60;
                        target.hitByFireballThisFrame = true;
                    }
                });
                if(fb.duration <= 0) {
                    activeFireballs.splice(index, 1);
                    targets.forEach(target => target.hitByFireballThisFrame = false);
                }
            });
            activeOilSpills.forEach((oil, index) => {
                oil.duration -= deltaTime;
                if (oil.duration <= 0) {
                    activeOilSpills.splice(index, 1);
                } else {
                    const targets = gameState === 'BOSS_WAVE' && boss ? [boss] : enemies;
                    targets.forEach(target => {
                        if (target.x < oil.x + oil.width && target.x + target.width > oil.x &&
                            target.y < oil.y + oil.height && target.y + target.height > oil.y) {
                            if (!target.lastOilDamageTime || Date.now() - target.lastOilDamageTime > 500) {
                                target.health -= 15;
                                target.lastOilDamageTime = Date.now();
                                playSound('burn_damage');
                            }
                        }
                    });
                }
            });


            if (gameState === 'DEFENDING' || gameState === 'BOSS_WAVE') {
                bolts.forEach((bolt, index) => { bolt.x += bolt.vx * deltaTime; bolt.y += bolt.vy * deltaTime; bolt.rotation = Math.atan2(bolt.vy, bolt.vx); if (bolt.y < 0 || bolt.x < 0 || bolt.x > canvas.width || bolt.y > canvas.height) bolts.splice(index,1); });

                ghoulBolts.forEach((gBolt, index) => {
                    gBolt.x += gBolt.vx * deltaTime;
                    gBolt.y += gBolt.vy * deltaTime;
                    const parapetTopY = canvas.height - (30 * PIXEL_SCALE);
                    if (gBolt.y + gBolt.height/2 >= parapetTopY && gBolt.x > 0 && gBolt.x < canvas.width) {
                        towerHealth -= 5;
                        playSound('tower_hit_ranged');
                        updateHealthDisplay();
                        ghoulBolts.splice(index, 1);
                        if (towerHealth <= 0) gameOver("The Gh큰ls have breached the tower!");
                    } else if (gBolt.y > canvas.height || gBolt.x < 0 || gBolt.x > canvas.width) {
                        ghoulBolts.splice(index, 1);
                    }
                });

                bossProjectiles.forEach((bp, index) => {
                    bp.y += bp.vy * deltaTime;
                    const parapetTopY = canvas.height - (30 * PIXEL_SCALE);
                    if (bp.y + bp.height/2 >= parapetTopY && bp.x > 0 && bp.x < canvas.width) {
                        towerHealth -= bp.damageToTower;
                        playSound('tower_hit_boss_projectile');
                        updateHealthDisplay();
                        bossProjectiles.splice(index, 1);
                        if (towerHealth <= 0) gameOver("Jer'Ghuul's magic has shattered the tower!");
                    } else if (bp.y > canvas.height) {
                        bossProjectiles.splice(index, 1);
                    }
                });


                const targets = gameState === 'BOSS_WAVE' && boss ? [boss] : enemies;

                targets.forEach((target, tIndex) => {
                    if (!enemiesFrozen || (gameState === 'BOSS_WAVE' && target === boss)) {
                         target.y += target.speed * deltaTime;
                         if (target.type === 'ranged' && target.y >= target.stopDistance) {
                             target.speed = 0;
                             target.attackTimer -= deltaTime;
                             if(target.attackTimer <=0) {
                                 const angleToTower = Math.atan2(player.y - (target.y + target.height/2), player.x - (target.x + target.width/2));
                                 ghoulBolts.push({
                                     x: target.x + target.width/2, y: target.y + target.height/2,
                                     vx: Math.cos(angleToTower) * 150 * PIXEL_SCALE,
                                     vy: Math.sin(angleToTower) * 150 * PIXEL_SCALE,
                                     width: 2*PIXEL_SCALE, height: 2*PIXEL_SCALE, color: ghulColors.projectile
                                 });
                                 playSound('ghoul_ranged_attack');
                                 target.attackTimer = target.attackCooldown;
                             }
                         }
                    }
                    if (target.y + target.height > player.y - 5 * PIXEL_SCALE) {
                        if (gameState === 'BOSS_WAVE' && target === boss) {
                            boss = null; // Or rather, boss.health <= 0 handled below
                            gameOver("Jer'Ghuul has destroyed the watchtower!");
                        } else {
                            enemies.splice(tIndex, 1);
                        }
                        let damageFromEnemy = target.damageToTower || 10;
                        if (player.hasStakes && (!target.hitByStakes)) {
                            target.health -= 20;
                            target.hitByStakes = true;
                            playSound('stakes_hit');
                            if (target.health <= 0) {
                                if (gameState !== 'BOSS_WAVE') enemies.splice(tIndex, 1); else boss = null;
                                score += 5; silver += 2; updateScoreDisplay(); updateSilverDisplay();
                                return; // Avoid further processing for this now-dead enemy
                            }
                        }
                        towerHealth -= damageFromEnemy;
                        playSound('tower_damage');
                        updateHealthDisplay();
                        if (towerHealth <= 0) gameOver("The Gh큰ls have breached the tower!");
                    }
                });

                for (let bIndex = bolts.length - 1; bIndex >= 0; bIndex--) {
                    const bolt = bolts[bIndex];
                    let boltRemoved = false;
                    for (let bpIndex = bossProjectiles.length - 1; bpIndex >= 0; bpIndex--) {
                        const bp = bossProjectiles[bpIndex];
                        if (bolt.x < bp.x + bp.width && bolt.x + bolt.width > bp.x &&
                            bolt.y < bp.y + bp.height && bolt.y + bolt.height > bp.y) {
                            bossProjectiles.splice(bpIndex, 1);
                            bolts.splice(bIndex, 1);
                            boltRemoved = true;
                            playSound('projectile_destroy');
                            score += 2;
                            break; // Bolt hit a boss projectile
                        }
                    }
                    if (boltRemoved) continue; // Move to next bolt

                    for (let tIndex = targets.length - 1; tIndex >= 0; tIndex--) {
                        const target = targets[tIndex];
                        if (bolt.x < target.x + target.width && bolt.x + bolt.width > target.x && bolt.y < target.y + target.height && bolt.y + bolt.height > target.y) {
                            target.health -= bolt.damage;
                            playSound('bolt_hit_flesh');
                            if (player.hasPiercingBoltsUpgrade && bolt.pierceCount > 0) {
                                bolt.pierceCount--;
                            } else {
                                bolts.splice(bIndex, 1);
                                boltRemoved = true;
                            }
                            if (target.health <= 0) {
                                if (gameState === 'BOSS_WAVE' && target === boss) {
                                    boss = null; gameState = 'VICTORY_CUTSCENE'; cutsceneStage = 0; cutsceneTimer = Date.now(); playSound('boss_death');
                                    showMessage("Jer'Ghuul The Dark has been Vanquished!", 5000, () => { updateControls(); draw(); });
                                } else {
                                    enemies.splice(tIndex, 1);
                                }
                                score += (gameState === 'BOSS_WAVE' ? 500 : 10);
                                silver += (gameState === 'BOSS_WAVE' ? 100 : 5);
                                updateScoreDisplay(); updateSilverDisplay();
                            }
                            if (boltRemoved) break; // Bolt hit a target, move to next bolt
                        }
                    }
                }

                if (gameState === 'DEFENDING' && Math.random() < 0.012 + (wave * 0.006) && enemies.length < 6 + wave * 1.5) spawnEnemy();
                if (gameState === 'DEFENDING' && enemies.length === 0 && (Date.now() - lastEnemySpawnTime > 5000 || totalEnemiesForWave <= 0) && towerHealth > 0) { if (enemiesToSpawnThisWave <=0) waveCleared(); }

                if (gameState === 'BOSS_WAVE' && boss) {
                    // Boss minion summon
                    if (boss.health <= boss.maxHealth * 0.75 && !boss.summonedAt75) {
                        for(let i=0; i<2; i++) spawnEnemy('skirmisher');
                        boss.summonedAt75 = true; playSound('boss_summon_minions');
                    } else if (boss.health <= boss.maxHealth * 0.50 && !boss.summonedAt50) {
                        for(let i=0; i<1; i++) spawnEnemy('armored');
                        for(let i=0; i<1; i++) spawnEnemy('ranged');
                        boss.summonedAt50 = true; playSound('boss_summon_minions');
                    } else if (boss.health <= boss.maxHealth * 0.25 && !boss.summonedAt25) {
                        for(let i=0; i<3; i++) spawnEnemy('skirmisher');
                        boss.summonedAt25 = true; playSound('boss_summon_minions');
                    }
                    // Boss projectile attack
                    boss.attackTimer -= deltaTime;
                    if (boss.attackTimer <= 0) {
                        const angleToTower = Math.atan2(player.y - (boss.y + boss.height/2), player.x - (boss.x + boss.width/2));
                        bossProjectiles.push({
                            x: boss.x + boss.width/2, y: boss.y + boss.height/2,
                            vx: Math.cos(angleToTower) * 75 * PIXEL_SCALE,
                            vy: Math.sin(angleToTower) * 75 * PIXEL_SCALE,
                            width: 5*PIXEL_SCALE, height: 5*PIXEL_SCALE,
                            color: ghulColors.boss_projectile || '#4B0082',
                            damageToTower: 20, health: 1
                        });
                        playSound('boss_projectile_fire');
                        boss.attackTimer = boss.attackCooldown;
                    }
                }
            }
        }
        function startNextWave() {
            player.currentAmmo = player.equippedCrossbow.ammoCapacity;
            updateAmmoDisplay();

            if (wave > MAX_WAVES) {
                gameState = 'BOSS_WAVE'; enemies = []; boss = spawnBoss(); totalEnemiesForWave = 1; enemiesToSpawnThisWave = 0;
                playSound('boss_roar'); showMessage("Jer'Ghuul The Dark Appears!", 3000, () => { if (gameLoopRequestId) cancelAnimationFrame(gameLoopRequestId); lastTime = performance.now(); gameLoopRequestId = requestAnimationFrame(gameLoop); });
            } else {
                gameState = 'DEFENDING'; totalEnemiesForWave = 5 + Math.floor(wave * 2.0 * difficultySettings[difficulty].countFactor);
                enemiesToSpawnThisWave = totalEnemiesForWave;
                enemies = []; bolts = []; ghoulBolts = []; activeOilSpills = []; bossProjectiles = [];
                updateWaveDisplay(); lastEnemySpawnTime = Date.now();
                playSound('wave_start_horn'); showMessage(`Wave ${wave} Incoming!`, 2000, () => { if (gameLoopRequestId) cancelAnimationFrame(gameLoopRequestId); lastTime = performance.now(); gameLoopRequestId = requestAnimationFrame(gameLoop); });
            }
        }
        function waveCleared() {
            gameState = 'WAVE_CLEARED';
            if (gameLoopRequestId) cancelAnimationFrame(gameLoopRequestId);
            let waveBonusSilver = 150 * difficultySettings[difficulty].silverFactor;
            silver += Math.floor(waveBonusSilver);
            updateSilverDisplay(); playSound('wave_clear_fanfare');

            if (wave >= MAX_WAVES && gameState !== 'BOSS_WAVE') {
                wave++; showMessage(`The Final Seal Weakens... Prepare for the Master!`, 4000, () => { gameState = 'TOWER_INTERIOR'; updateControls(); draw(); if(gameState === 'TOWER_INTERIOR' && (!gameLoopRequestId || !ctx.canvas.offsetParent) ){ let interiorAnimId; function animateInteriorLoop() { if (gameState !== 'TOWER_INTERIOR') { cancelAnimationFrame(interiorAnimId); return; } draw(); interiorAnimId = requestAnimationFrame(animateInteriorLoop); } animateInteriorLoop();}});
            } else if (gameState !== 'BOSS_WAVE') {
                wave++; showMessage(`Wave ${wave-1} Cleared! +${Math.floor(waveBonusSilver)} Silver. Returning to Tower...`, 3000, () => { gameState = 'TOWER_INTERIOR'; updateControls(); draw(); if(gameState === 'TOWER_INTERIOR' && (!gameLoopRequestId || !ctx.canvas.offsetParent) ){ let interiorAnimId; function animateInteriorLoop() { if (gameState !== 'TOWER_INTERIOR') { cancelAnimationFrame(interiorAnimId); return; } draw(); interiorAnimId = requestAnimationFrame(animateInteriorLoop); } animateInteriorLoop();}});
            }
        }

        // Helper to draw images centered and maintaining aspect ratio
        function drawScaledImage(imgKey, fallbackColor = '#333') {
            const imgToDraw = loadedImages[imgKey];
            if (imgToDraw && imgToDraw.complete && !imgToDraw.error) {
                const canvasAspect = canvas.width / canvas.height;
                const imgAspect = imgToDraw.naturalWidth / imgToDraw.naturalHeight;
                let drawWidth, drawHeight, drawX, drawY;

                if (imgAspect > canvasAspect) { // Image is wider than canvas
                    drawWidth = canvas.width;
                    drawHeight = drawWidth / imgAspect;
                } else { // Image is taller or same aspect as canvas
                    drawHeight = canvas.height;
                    drawWidth = drawHeight * imgAspect;
                }
                drawX = (canvas.width - drawWidth) / 2;
                drawY = (canvas.height - drawHeight) / 2;
                ctx.drawImage(imgToDraw, drawX, drawY, drawWidth, drawHeight);
            } else {
                ctx.fillStyle = fallbackColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.font = `${6 * PIXEL_SCALE}px 'Courier New', monospace`;
                // Display the problematic path if available from the error object
                const pathInfo = (imgToDraw && imgToDraw.srcPath) ? imgToDraw.srcPath : imgKey;
                ctx.fillText(imgToDraw && imgToDraw.error ? `Error loading: ${pathInfo}` : `Loading: ${imgKey}...`, canvas.width / 2, canvas.height / 2);
            }
        }


        function drawIntroCutscene() {
            const frame = introCutsceneFrames[cutsceneStage];
            if (!frame) return;
            drawScaledImage(frame.imageKey, nightEnvironmentColors.sky_gradient_bottom);
            cutsceneTextOverlay.innerHTML = frame.text.replace(/\n/g, "<br>");
            cutsceneTextOverlay.style.display = 'block';
        }

        function drawVictoryCutscene() {
            const frame = victoryCutsceneFrames[cutsceneStage];
            if (!frame) return;
            drawScaledImage(frame.imageKey, dayEnvironmentColors.sky_gradient_bottom);
            cutsceneTextOverlay.innerHTML = frame.text.replace(/\n/g, "<br>");
            cutsceneTextOverlay.style.display = 'block';
        }


        function draw() {
            const isDayTime = (wave <= MAX_WAVES && wave % 2 === 0 && wave > 0) || (gameState === 'BOSS_WAVE' && wave % 2 === 0);
            const currentEnv = isDayTime ? dayEnvironmentColors : nightEnvironmentColors;
            const grad = ctx.createLinearGradient(0,0,0,canvas.height);
            grad.addColorStop(0, currentEnv.sky_gradient_top); grad.addColorStop(1, currentEnv.sky_gradient_bottom);
            ctx.fillStyle = grad; ctx.fillRect(0,0,canvas.width,canvas.height);

            if (gameState === 'START_SCREEN') drawStartScreen();
            else if (gameState === 'INTRO_CUTSCENE') drawIntroCutscene();
            else if (gameState === 'TOWER_INTERIOR') drawTowerInteriorScreen();
            else if (gameState === 'SHOP') drawShopScreen();
            else if (gameState === 'SETTINGS') drawSettingsScreen();
            else if (gameState === 'DEFENDING' || gameState === 'WAVE_CLEARED' || gameState === 'BOSS_WAVE') {
                drawDefenseScreen(isDayTime, currentEnv);
                bolts.forEach(drawBolt); ghoulBolts.forEach(drawGhoulBolt); activeOilSpills.forEach(drawOilSpill); bossProjectiles.forEach(drawBossProjectile);
                if(gameState === 'BOSS_WAVE' && boss) drawBoss(boss, isDayTime);
                enemies.forEach(enemy => drawEnemy(enemy, isDayTime));
                drawPlayerCrossbow();
                activeFireballs.forEach(fb => { ctx.fillStyle = `rgba(255, ${100 + Math.random()*100}, 0, ${fb.duration / 1.0})`; ctx.beginPath(); ctx.arc(fb.x, fb.y, fb.radius, 0, Math.PI*2); ctx.fill();});
            } else if (gameState === 'GAME_OVER') drawGameOverScreen();
            else if (gameState === 'VICTORY_CUTSCENE') drawVictoryCutscene();
            else if (gameState === 'VICTORY') drawVictoryScreen();
        }
        function generateInteriorDetails() {
            interiorDetails = {
                stonePatches: Array.from({length: 25}, () => ({ x: Math.random() * BASE_CANVAS_WIDTH, y: Math.random() * (BASE_CANVAS_HEIGHT * 0.6), w: (Math.random()*4+2), h: (Math.random()*4+2), color: Math.random() > 0.6 ? commonEnvironmentColors.tower_stone_darker : commonEnvironmentColors.tower_stone_highlight })),
                table: { x: BASE_CANVAS_WIDTH*0.25, y: BASE_CANVAS_HEIGHT*0.75, w: 60*1.2, h: 25*1.2, items: [{type: 'tankard', x:5, y:-5}, {type: 'map', x:25, y:-3}, {type: 'candle', x:50, y:-6}, {type: 'bread', x:15, y:-4}]},
                bed: { x: BASE_CANVAS_WIDTH*0.7, y: BASE_CANVAS_HEIGHT*0.8, w: 30*1.2, h: 50*1.2},
                shelf: { x: BASE_CANVAS_WIDTH*0.1, y: BASE_CANVAS_HEIGHT*0.35, w:50, h:5, items: [{type:'book', x:5, y:-8, color:'#5D4037'}, {type:'potion', x:20, y:-10, color:'#29B6F6'}, {type:'book', x:35, y:-8, color:'#795548'}]},
                floorboards: Array.from({length: Math.floor((BASE_CANVAS_HEIGHT*0.4)/8)}, (_,i) => ({y: BASE_CANVAS_HEIGHT*0.6 + i*8, darkLines: Array.from({length: Math.floor(BASE_CANVAS_WIDTH/10)}, () => Math.random() > 0.7)})),
                weaponRack: { x: BASE_CANVAS_WIDTH*0.85, y: BASE_CANVAS_HEIGHT*0.2, items: [{type:'sword', angle:0.2}, {type:'axe', angle:-0.1}]},
                wallHanging: { x: BASE_CANVAS_WIDTH*0.5, y: BASE_CANVAS_HEIGHT*0.15, width: 30, height:40, color: bertoldColors.cloth, emblemColor: bertoldColors.trim},
                paviseShields: [
                    {x: BASE_CANVAS_WIDTH*0.05, y: BASE_CANVAS_HEIGHT*0.65, width:18, height:30, angle: 0.1},
                    {x: BASE_CANVAS_WIDTH*0.9, y: BASE_CANVAS_HEIGHT*0.7, width:18, height:30, angle: -0.15}
                ],
                crossedCrossbows: {x: BASE_CANVAS_WIDTH * 0.5, y: BASE_CANVAS_HEIGHT * 0.25, size: 25},
                chair: {x: BASE_CANVAS_WIDTH * 0.35, y: BASE_CANVAS_HEIGHT * 0.72, scale: 1.5}
            };
        }
        function drawStartScreen() {
            const bgImage = loadedImages['start_screen_bg'];

            if (bgImage && bgImage.complete && !bgImage.error) {
                const canvasAspect = canvas.width / canvas.height;
                const imgAspect = bgImage.naturalWidth / bgImage.naturalHeight;
                let drawWidth, drawHeight, drawX, drawY;

                if (imgAspect > canvasAspect) {
                    drawHeight = canvas.height;
                    drawWidth = drawHeight * imgAspect;
                    drawX = (canvas.width - drawWidth) / 2;
                    drawY = 0;
                } else {
                    drawWidth = canvas.width;
                    drawHeight = drawWidth / imgAspect;
                    drawX = 0;
                    drawY = (canvas.height - drawHeight) / 2;
                }
                ctx.drawImage(bgImage, drawX, drawY, drawWidth, drawHeight);
            } else {
                ctx.fillStyle = nightEnvironmentColors.sky_gradient_bottom;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                if (bgImage && bgImage.error) { // Check if bgImage object exists and has error flag
                    ctx.fillStyle = 'red';
                    ctx.textAlign = 'center';
                    ctx.font = `${8 * PIXEL_SCALE}px 'Courier New', monospace`;
                    ctx.fillText(`Error: ${bgImage.srcPath || 'start_screen_bg'}. Check path.`, canvas.width / 2, canvas.height / 2 - 60 * PIXEL_SCALE);
                } else if (!bgImage) { // Image object itself is missing from loadedImages
                     ctx.fillStyle = 'orange';
                    ctx.textAlign = 'center';
                    ctx.font = `${8 * PIXEL_SCALE}px 'Courier New', monospace`;
                    ctx.fillText("Loading start_screen_bg...", canvas.width / 2, canvas.height / 2 - 60 * PIXEL_SCALE);
                }
            }

            // Draw text overlays
            ctx.font = `bold ${42 * PIXEL_SCALE}px 'Courier New', monospace`;
            ctx.textAlign = 'center';
            ctx.fillStyle = '#000000'; // Shadow
            ctx.fillText("Bertold's Watch", canvas.width/2 + 2*PIXEL_SCALE, canvas.height/3.5 + 2*PIXEL_SCALE);
            ctx.fillStyle = bertoldColors.trim; // Main text
            ctx.fillText("Bertold's Watch", canvas.width/2, canvas.height/3.5);

            ctx.font = `${12 * PIXEL_SCALE}px 'Courier New', monospace`;
            ctx.fillStyle = '#e0dacd';
            ctx.fillText("The Gh큰ls stir... Defend the watchtower!", canvas.width/2, canvas.height/2 + 25*PIXEL_SCALE);

            ctx.font = `${8 * PIXEL_SCALE}px 'Courier New', monospace`;
            ctx.fillText("Press 'R' to Reload. Good luck, Watchman.", canvas.width/2, canvas.height/2 + 55*PIXEL_SCALE);
        }
        function drawTowerInteriorScreen() {
            const isDayTime = (wave % 2 === 0 && wave > 0);
            const currentSkyColor = isDayTime ? dayEnvironmentColors.sky_gradient_bottom : nightEnvironmentColors.sky_gradient_bottom; // Corrected sky reference

            const floorTopY = BASE_CANVAS_HEIGHT * 0.65 * PIXEL_SCALE;
            const floorBottomY = canvas.height; const plankHeight = 10 * PIXEL_SCALE;
            for(let y = floorTopY; y < floorBottomY; y += plankHeight) {
                const perspectiveFactor = 1 - ((y - floorTopY) / (floorBottomY - floorTopY)) * 0.2;
                const currentPlankHeight = plankHeight * perspectiveFactor;
                ctx.fillStyle = (Math.floor((y-floorTopY)/plankHeight)%2===0) ? commonEnvironmentColors.tower_wood : commonEnvironmentColors.tower_wood_dark;
                ctx.fillRect(0, y, canvas.width, currentPlankHeight);
                ctx.fillStyle = 'rgba(0,0,0,0.15)';
                // Ensure floorboards and darkLines exist before trying to access
                if (interiorDetails.floorboards && interiorDetails.floorboards[0] && interiorDetails.floorboards[0].darkLines) {
                    for(let j=0; j < BASE_CANVAS_WIDTH / 12; j++){ if(interiorDetails.floorboards[0].darkLines[j]) ctx.fillRect(j*12*PIXEL_SCALE, y, PIXEL_SCALE * 0.8 * perspectiveFactor, currentPlankHeight); }
                }
            }
            const wallTopY = 0; const wallBottomY = floorTopY; const TILE_SIZE = 12 * PIXEL_SCALE;
            for (let y = wallTopY; y < wallBottomY; y += TILE_SIZE) { for (let x = 0; x < canvas.width; x += TILE_SIZE) { if (((x / TILE_SIZE) % 2 === 0 && (y / TILE_SIZE) % 2 === 0) || ((x / TILE_SIZE) % 2 !== 0 && (y / TILE_SIZE) % 2 !== 0)) { ctx.fillStyle = commonEnvironmentColors.tower_stone; } else { ctx.fillStyle = commonEnvironmentColors.tower_stone_darker; } ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE); } }
            interiorDetails.stonePatches.forEach(p => { if(p.y*PIXEL_SCALE < wallBottomY) {ctx.fillStyle = p.color; ctx.fillRect(p.x*PIXEL_SCALE, p.y*PIXEL_SCALE, p.w*PIXEL_SCALE, p.h*PIXEL_SCALE);}});
            const winX_interior=25*PIXEL_SCALE, winY_interior=25*PIXEL_SCALE, winW_interior=(BASE_CANVAS_WIDTH*0.25)*PIXEL_SCALE, winH_interior=(BASE_CANVAS_HEIGHT*0.20)*PIXEL_SCALE;
            if (winY_interior + winH_interior < wallBottomY) {
                ctx.fillStyle = currentSkyColor; ctx.fillRect(winX_interior,winY_interior,winW_interior,winH_interior);
                ctx.fillStyle = isDayTime ? dayEnvironmentColors.forest_far : nightEnvironmentColors.forest_far;
                ctx.fillRect(winX_interior, winY_interior+winH_interior*0.6, winW_interior, winH_interior*0.4);
                ctx.strokeStyle = commonEnvironmentColors.tower_wood_dark; ctx.lineWidth = 3*PIXEL_SCALE; ctx.strokeRect(winX_interior,winY_interior,winW_interior,winH_interior);
                ctx.beginPath(); ctx.moveTo(winX_interior+winW_interior/2,winY_interior);ctx.lineTo(winX_interior+winW_interior/2,winY_interior+winH_interior); ctx.moveTo(winX_interior,winY_interior+winH_interior/2);ctx.lineTo(winX_interior+winW_interior,winY_interior+winH_interior/2); ctx.stroke();
            }
            const hearthX = BASE_CANVAS_WIDTH*0.7*PIXEL_SCALE, hearthY = BASE_CANVAS_HEIGHT*0.40*PIXEL_SCALE;
            const hearthW = 50*PIXEL_SCALE, hearthH = 40*PIXEL_SCALE;
            const mantleHeight = 4*PIXEL_SCALE;
            if (hearthY < wallBottomY - hearthH) {
                ctx.fillStyle = commonEnvironmentColors.tower_wood_dark;
                ctx.fillRect(hearthX - 2*PIXEL_SCALE, hearthY - mantleHeight, hearthW + 4*PIXEL_SCALE, mantleHeight);
                for(let r=0; r<4; r++) { for(let c=0; c<5; c++) { ctx.fillStyle = (r+c)%2===0 ? '#5a3e4a' : '#4a2e3a'; ctx.fillRect(hearthX+c*10*PIXEL_SCALE, hearthY+r*10*PIXEL_SCALE,10*PIXEL_SCALE,10*PIXEL_SCALE);}}
                const fireBaseX = hearthX+10*PIXEL_SCALE, fireBaseY = hearthY+10*PIXEL_SCALE;
                if (Date.now() - fireFlickerState.lastPhaseChange > fireFlickerState.interval) { fireFlickerState.phase = (fireFlickerState.phase + 1) % 3; fireFlickerState.lastPhaseChange = Date.now(); }
                for(let i=0; i<5; i++){ let fh = (10 + Math.sin(frameCount * 0.05 + i + fireFlickerState.phase * Math.PI/1.5) * 5 + 5) * PIXEL_SCALE; ctx.fillStyle = [commonEnvironmentColors.fire_red, commonEnvironmentColors.fire_orange, commonEnvironmentColors.fire_yellow][(i + fireFlickerState.phase) % 3]; ctx.fillRect(fireBaseX+i*5*PIXEL_SCALE, fireBaseY + (20*PIXEL_SCALE-fh), 4*PIXEL_SCALE, Math.max(0, fh)); }
            }
            const tbl=interiorDetails.table; tbl.y = BASE_CANVAS_HEIGHT*0.7; tbl.w = 70*PIXEL_SCALE * 1.2; tbl.h = 30*PIXEL_SCALE * 1.2;
            ctx.fillStyle=commonEnvironmentColors.tower_wood_dark; ctx.fillRect(tbl.x*PIXEL_SCALE, tbl.y*PIXEL_SCALE, tbl.w, tbl.h);
            ctx.fillRect((tbl.x+5)*PIXEL_SCALE, (tbl.y+tbl.h), 6*PIXEL_SCALE, 18*PIXEL_SCALE); ctx.fillRect((tbl.x+tbl.w-11*PIXEL_SCALE), (tbl.y+tbl.h), 6*PIXEL_SCALE, 18*PIXEL_SCALE);
            tbl.items.forEach(it => { if(it.type==='tankard'){ctx.fillStyle='#757575'; ctx.fillRect((tbl.x+it.x*1.2)*PIXEL_SCALE, (tbl.y+it.y*1.2)*PIXEL_SCALE, 10*PIXEL_SCALE*1.2,12*PIXEL_SCALE*1.2); ctx.fillRect((tbl.x+(it.x+10)*1.2)*PIXEL_SCALE, (tbl.y+(it.y+2)*1.2)*PIXEL_SCALE, 4*PIXEL_SCALE*1.2,6*PIXEL_SCALE*1.2);} if(it.type==='map'){ctx.fillStyle='#E0C0A0'; ctx.fillRect((tbl.x+it.x*1.2)*PIXEL_SCALE, (tbl.y+it.y*1.2)*PIXEL_SCALE, 18*PIXEL_SCALE*1.2,7*PIXEL_SCALE*1.2); ctx.fillStyle='#A08060'; ctx.fillRect((tbl.x+(it.x+2)*1.2)*PIXEL_SCALE, (tbl.y+(it.y+1)*1.2)*PIXEL_SCALE, 14*PIXEL_SCALE*1.2,5*PIXEL_SCALE*1.2);} if(it.type==='candle'){ctx.fillStyle='#FFF59D'; ctx.fillRect((tbl.x+it.x*1.2)*PIXEL_SCALE, (tbl.y+it.y*1.2)*PIXEL_SCALE, 4*PIXEL_SCALE*1.2,10*PIXEL_SCALE*1.2); ctx.fillStyle=commonEnvironmentColors.candle_flame; ctx.fillRect((tbl.x+it.x*1.2)*PIXEL_SCALE, (tbl.y+(it.y-5)*1.2)*PIXEL_SCALE, 4*PIXEL_SCALE*1.2,5*PIXEL_SCALE*1.2);} if(it.type==='bread'){ctx.fillStyle='#C68E17'; ctx.beginPath(); ctx.ellipse((tbl.x+(it.x+6)*1.2)*PIXEL_SCALE, (tbl.y+(it.y+3)*1.2)*PIXEL_SCALE, 6*PIXEL_SCALE*1.2, 3.5*PIXEL_SCALE*1.2,0,0,Math.PI*2); ctx.fill();}});
            const bd=interiorDetails.bed; bd.y = BASE_CANVAS_HEIGHT*0.78; bd.w = 40*PIXEL_SCALE * 1.2; bd.h = 60*PIXEL_SCALE * 1.2;
            ctx.fillStyle=commonEnvironmentColors.tower_wood_dark; ctx.fillRect(bd.x*PIXEL_SCALE, bd.y*PIXEL_SCALE, bd.w, bd.h);
            ctx.fillStyle = '#4682B4'; // Subdued blue for blanket
            ctx.fillRect((bd.x+4)*PIXEL_SCALE, (bd.y+4)*PIXEL_SCALE, (bd.w-8)*PIXEL_SCALE, (bd.h-8)*PIXEL_SCALE);
            ctx.fillStyle='#E0E0E0'; ctx.fillRect((bd.x+7)*PIXEL_SCALE, (bd.y+7)*PIXEL_SCALE, (bd.w-14)*PIXEL_SCALE, 15*PIXEL_SCALE);
            ctx.fillStyle=commonEnvironmentColors.tower_wood; ctx.fillRect(bd.x*PIXEL_SCALE, (bd.y+bd.h)*PIXEL_SCALE, bd.w, 6*PIXEL_SCALE);

            const sh=interiorDetails.shelf; sh.y = BASE_CANVAS_HEIGHT*0.3; if (sh.y * PIXEL_SCALE < wallBottomY - sh.h*PIXEL_SCALE - 10*PIXEL_SCALE) { ctx.fillStyle=commonEnvironmentColors.tower_wood; ctx.fillRect(sh.x*PIXEL_SCALE, sh.y*PIXEL_SCALE, sh.w*PIXEL_SCALE, sh.h*PIXEL_SCALE); sh.items.forEach(it => { if(it.type==='book'){ctx.fillStyle=it.color; ctx.fillRect((sh.x+it.x)*PIXEL_SCALE, (sh.y+it.y)*PIXEL_SCALE, 10*PIXEL_SCALE, 8*PIXEL_SCALE);} if(it.type==='potion'){ctx.fillStyle=it.color; ctx.beginPath(); ctx.arc((sh.x+it.x+4)*PIXEL_SCALE, (sh.y+it.y+4)*PIXEL_SCALE, 4*PIXEL_SCALE,0,Math.PI*2);ctx.fill(); ctx.fillRect((sh.x+it.x+3)*PIXEL_SCALE, (sh.y+it.y-2)*PIXEL_SCALE, 2*PIXEL_SCALE,2*PIXEL_SCALE); } }); }
            interiorDetails.paviseShields.forEach(shield => { drawPaviseShield(ctx, shield.x*PIXEL_SCALE, shield.y*PIXEL_SCALE, shield.width*PIXEL_SCALE*1.2, shield.height*PIXEL_SCALE*1.2, shield.angle); });
            const wr = interiorDetails.weaponRack; ctx.fillStyle = commonEnvironmentColors.tower_wood_dark; ctx.fillRect(wr.x, wr.y, 5*PIXEL_SCALE, 40*PIXEL_SCALE);
            wr.items.forEach((item, i) => { const itemY = wr.y + 5*PIXEL_SCALE + i*12*PIXEL_SCALE; if(item.type === 'sword'){ ctx.fillStyle = bertoldColors.armor; ctx.fillRect(wr.x - 10*PIXEL_SCALE, itemY, 25*PIXEL_SCALE, 3*PIXEL_SCALE); ctx.fillRect(wr.x + 1*PIXEL_SCALE, itemY-5*PIXEL_SCALE, 3*PIXEL_SCALE, 5*PIXEL_SCALE); } else if (item.type === 'axe') { ctx.fillStyle = bertoldColors.armor; ctx.fillRect(wr.x - 8*PIXEL_SCALE, itemY, 5*PIXEL_SCALE, 15*PIXEL_SCALE); ctx.beginPath(); ctx.ellipse(wr.x - 8*PIXEL_SCALE, itemY, 5*PIXEL_SCALE, 3*PIXEL_SCALE, 0, Math.PI*0.5, Math.PI*1.5, true); ctx.fill();}});
            const wh = interiorDetails.wallHanging; ctx.fillStyle = wh.color; ctx.fillRect(wh.x*PIXEL_SCALE - wh.width/2*PIXEL_SCALE, wh.y*PIXEL_SCALE, wh.width*PIXEL_SCALE, wh.height*PIXEL_SCALE); ctx.fillStyle = wh.emblemColor; ctx.fillRect(wh.x*PIXEL_SCALE - 3*PIXEL_SCALE, wh.y*PIXEL_SCALE + 10*PIXEL_SCALE, 6*PIXEL_SCALE, 20*PIXEL_SCALE); ctx.fillRect(wh.x*PIXEL_SCALE - 10*PIXEL_SCALE, wh.y*PIXEL_SCALE + 17*PIXEL_SCALE, 20*PIXEL_SCALE, 6*PIXEL_SCALE);
            const cc = interiorDetails.crossedCrossbows;
            ctx.save(); ctx.translate(cc.x*PIXEL_SCALE, cc.y*PIXEL_SCALE);
            ctx.rotate(-0.3); drawDecorativeCrossbow(ctx, 0,0, cc.size*PIXEL_SCALE); ctx.rotate(0.6); drawDecorativeCrossbow(ctx, 0,0, cc.size*PIXEL_SCALE);
            ctx.restore();
            const ch = interiorDetails.chair;
            drawChair(ctx, ch.x * PIXEL_SCALE, ch.y * PIXEL_SCALE, PIXEL_SCALE * ch.scale);

            drawBertold(ctx, canvas.width*0.4, canvas.height * 0.82, PIXEL_SCALE * 2.2, 0.1, true, false);
            ctx.font = `${8*PIXEL_SCALE}px 'Courier New', monospace`;
            ctx.fillStyle = '#e0dacd'; ctx.textAlign = 'center'; ctx.fillText("Bertold's quarters. A brief respite.", canvas.width/2, 20*PIXEL_SCALE);
        }
        function drawChair(ctx, x, y, scale) {
            const s = scale * 1.2;
            ctx.fillStyle = commonEnvironmentColors.tower_wood;
            ctx.fillRect(x - 2.5*s, y - 18*s, 5*s, 22*s);
            ctx.fillRect(x - 7*s, y - 16*s, 14*s, 4*s);
            ctx.fillRect(x - 8*s, y, 16*s, 5*s);
            ctx.fillRect(x - 7*s, y + 5*s, 4*s, 12*s);
            ctx.fillRect(x + 3*s, y + 5*s, 4*s, 12*s);
            ctx.fillStyle = commonEnvironmentColors.tower_wood_dark;
            ctx.fillRect(x - 2.5*s, y + 5*s, 4*s, 12*s);
        }
        function drawDecorativeCrossbow(ctx, x, y, size) {
            ctx.fillStyle = bertoldColors.wood; ctx.fillRect(x - size/2, y - size/8, size, size/4);
            ctx.fillStyle = bertoldColors.armor; ctx.fillRect(x + size/4, y - size/3, size/8, size*2/3);
        }
        function drawShopScreen() {
            ctx.fillStyle = commonEnvironmentColors.tower_stone_darker; ctx.fillRect(0,0,canvas.width,canvas.height);
            shopBackgroundDetails.forEach(detail => { ctx.fillStyle = detail.color || commonEnvironmentColors.tower_wood_dark; if (detail.type === 'shelf') { ctx.fillRect(detail.x, detail.y, detail.width, detail.height); ctx.fillStyle = commonEnvironmentColors.tower_wood; ctx.fillRect(detail.x + 5*PIXEL_SCALE, detail.y + detail.height, 4*PIXEL_SCALE, 10*PIXEL_SCALE); ctx.fillRect(detail.x + detail.width - 9*PIXEL_SCALE, detail.y + detail.height, 4*PIXEL_SCALE, 10*PIXEL_SCALE); } else if (detail.type === 'bg_crossbow') { ctx.save(); ctx.translate(detail.x + detail.width/2, detail.y + detail.height/2); ctx.rotate(detail.angle || 0); ctx.fillStyle = bertoldColors.wood; ctx.fillRect(-detail.width/2, -detail.height/4, detail.width, detail.height/2); ctx.fillStyle = bertoldColors.armor; ctx.fillRect(-detail.width/4, -detail.height/2, detail.width/2, detail.height); ctx.restore(); } else if (detail.type === 'bg_bolts') { ctx.fillStyle = '#8D6E63'; ctx.fillRect(detail.x, detail.y, 6*PIXEL_SCALE, 10*PIXEL_SCALE); ctx.fillStyle = '#D2B48C'; for(let b=0; b < detail.count; b++) { ctx.fillRect(detail.x + 1*PIXEL_SCALE + (b%2)*2*PIXEL_SCALE , detail.y - 4*PIXEL_SCALE + (b%3)*PIXEL_SCALE, PIXEL_SCALE, 4*PIXEL_SCALE); } } else if (detail.type === 'bg_book') { ctx.fillStyle = detail.color; ctx.fillRect(detail.x, detail.y, detail.width, detail.height); ctx.fillStyle = commonEnvironmentColors.book_pages; ctx.fillRect(detail.x + detail.width - PIXEL_SCALE, detail.y + PIXEL_SCALE, PIXEL_SCALE, detail.height - 2*PIXEL_SCALE); } else if (detail.type === 'bg_potion') { ctx.fillStyle = detail.color; ctx.beginPath(); ctx.arc(detail.x + detail.radius, detail.y + detail.radius, detail.radius, 0, Math.PI*2); ctx.fill(); ctx.fillRect(detail.x + detail.radius - PIXEL_SCALE, detail.y - 2*PIXEL_SCALE, 2*PIXEL_SCALE, 2*PIXEL_SCALE); } else if (detail.type === 'bg_helmet') { ctx.fillStyle = bertoldColors.armor; ctx.beginPath(); ctx.arc(detail.x + detail.radius, detail.y + detail.radius, detail.radius, Math.PI, 0); ctx.fill(); ctx.fillRect(detail.x + detail.radius*0.5, detail.y + detail.radius*1.5, detail.radius, PIXEL_SCALE*2);} });
            ctx.font = `bold ${20 * PIXEL_SCALE}px 'Courier New', monospace`; ctx.fillStyle = bertoldColors.trim;
            ctx.textAlign = 'center'; ctx.fillText("Armory", canvas.width/2, 25*PIXEL_SCALE);
            ctx.font = `${8 * PIXEL_SCALE}px 'Courier New', monospace`; ctx.fillStyle = '#e0dacd';
            ctx.textAlign = 'right';
            ctx.fillText(`Silver: ${silver}`, canvas.width - 15*PIXEL_SCALE, 25*PIXEL_SCALE);
            ctx.textAlign = 'center';

            shopItemRects = [];
            const cols = 3;
            const itemCardWidth = (BASE_CANVAS_WIDTH / cols) * PIXEL_SCALE * 0.75;
            const itemCardHeight = 45 * PIXEL_SCALE;
            const horizontalGap = (canvas.width - (cols * itemCardWidth)) / (cols + 1);
            const verticalGap = 8 * PIXEL_SCALE;
            const startX = horizontalGap;
            const startY = 50 * PIXEL_SCALE;

            shopItems.forEach((item, index) => {
                if(!item) return;
                const col = index % cols;
                const row = Math.floor(index / cols);
                const itemX = startX + col * (itemCardWidth + horizontalGap);
                const itemY = startY + row * (itemCardHeight + verticalGap);
                const rect = {x:itemX, y:itemY, width:itemCardWidth, height:itemCardHeight, item:item};
                shopItemRects.push(rect);
                ctx.fillStyle = item.isOwned && !item.isConsumable && !(item.isUpgrade && !player[item.flag]) ? '#4a2e3a' : '#3a2e3a';
                ctx.fillRect(itemX, itemY, itemCardWidth, itemCardHeight);
                let borderColor = item.color || bertoldColors.trim;
                if(item.id === 'stakes_upgrade') borderColor = bertoldColors.trim; // Override for better visibility
                ctx.strokeStyle = borderColor;
                ctx.lineWidth = PIXEL_SCALE * 1.5;
                ctx.strokeRect(itemX, itemY, itemCardWidth, itemCardHeight);
                const iconSize = 8 * PIXEL_SCALE;
                const iconX = itemX + 3 * PIXEL_SCALE;
                const iconY = itemY + 3 * PIXEL_SCALE;
                ctx.fillStyle = item.color || '#ccc';
                if (item.isUpgrade) { ctx.beginPath(); ctx.moveTo(iconX + iconSize/2, iconY); ctx.lineTo(iconX + iconSize*0.2, iconY + iconSize*0.8); ctx.lineTo(iconX + iconSize*0.8, iconY + iconSize*0.8); ctx.closePath(); ctx.fill();
                } else if (item.isConsumable) { if(item.id === 'health_potion') { ctx.fillStyle=item.color; ctx.fillRect(iconX + iconSize*0.3, iconY, iconSize*0.4, iconSize); ctx.fillRect(iconX, iconY + iconSize*0.3, iconSize, iconSize*0.4);} else { ctx.fillStyle=item.color; ctx.beginPath(); ctx.rect(iconX, iconY, iconSize*0.7, iconSize); ctx.fill(); ctx.fillStyle='#333'; ctx.fillRect(iconX+1, iconY+1, iconSize*0.7-2, iconSize-2); ctx.fillStyle=item.color; ctx.fillRect(iconX+2, iconY+2, PIXEL_SCALE, PIXEL_SCALE*3); ctx.fillRect(iconX+4, iconY+4, PIXEL_SCALE, PIXEL_SCALE*3); }
                } else { ctx.fillRect(iconX, iconY + iconSize*0.4, iconSize, iconSize*0.2); ctx.fillRect(iconX + iconSize*0.6, iconY, iconSize*0.2, iconSize); }
                ctx.font = `bold ${5 * PIXEL_SCALE}px 'Courier New', monospace`;
                ctx.fillStyle = item.color; ctx.textAlign = 'left';
                let displayName = item.name.length > 12 ? item.name.substring(0,10) + "..." : item.name;
                ctx.fillText(displayName, itemX + iconSize + 6*PIXEL_SCALE, itemY + 6*PIXEL_SCALE);
                ctx.font = `${4 * PIXEL_SCALE}px 'Courier New', monospace`;
                ctx.fillStyle = '#e0dacd';
                let statusText = item.isOwned && !item.isConsumable && !(item.isUpgrade && !player[item.flag]) ? (player.equippedCrossbow && player.equippedCrossbow.id === item.id ? "[EQUIPPED]" : "[OWNED]") : (item.isUpgrade && player[item.flag] ? "LEARNED" : `${item.displayCost}s`);
                ctx.fillText(statusText, itemX + iconSize + 6*PIXEL_SCALE, itemY + 14*PIXEL_SCALE);

                if(item.damage) {
                    ctx.fillText(`Dmg:${item.damage} C:${item.ammoCapacity} R:${item.reloadTime.toFixed(1)}`, itemX + 3*PIXEL_SCALE, itemY + itemCardHeight - 12*PIXEL_SCALE);
                } else if (item.description) {
                     ctx.fillText(item.description.substring(0,20) + (item.description.length > 20 ? "..." : ""), itemX + 3*PIXEL_SCALE, itemY + itemCardHeight - 12*PIXEL_SCALE);
                }

                const buttonIndicatorW = 20 * PIXEL_SCALE; const buttonIndicatorH = 8 * PIXEL_SCALE;
                const buttonIndicatorX = itemX + itemCardWidth - buttonIndicatorW - 3*PIXEL_SCALE;
                const buttonIndicatorY = itemY + itemCardHeight - buttonIndicatorH - 3*PIXEL_SCALE;
                let buttonText = ""; let canAfford = true;
                if(item.isOwned && !item.isConsumable && !(item.isUpgrade && player[item.flag])){ buttonText = (player.equippedCrossbow && player.equippedCrossbow.id !== item.id) ? "Equip" : "";
                } else if (item.isUpgrade && player[item.flag]) { buttonText = "";
                } else { buttonText = "Buy"; if (silver < item.displayCost) canAfford = false; }
                if(buttonText) { ctx.fillStyle = canAfford ? '#5a3e4a' : '#444'; ctx.fillRect(buttonIndicatorX, buttonIndicatorY, buttonIndicatorW, buttonIndicatorH); ctx.fillStyle = canAfford ? '#e0dacd' : '#777'; ctx.textAlign = 'center'; ctx.font = `${3.5 * PIXEL_SCALE}px 'Courier New', monospace`; ctx.fillText(buttonText, buttonIndicatorX + buttonIndicatorW/2, buttonIndicatorY + buttonIndicatorH/2 + 1.5*PIXEL_SCALE); }
                ctx.textAlign = 'left';
            });
        }

        function drawDefenseScreen(isDayTime, currentEnv) {
            if (!defenseSceneElementsGenerated) {
                generateDefenseStars(80); generateFarForestTrees(); generateMidForestTrees(); generateDistantCastles(); generateParapetWall(); generateMountains(); generatePathTexture(); generateDefensePaviseShields();
                defenseSceneElementsGenerated = true;
            }
            mountains.forEach(mountain => { const mountainBaseColor = isDayTime ? currentEnv.mountain_base : nightEnvironmentColors.mountain_base; const mountainPeakColor = isDayTime ? currentEnv.mountain_peak : nightEnvironmentColors.mountain_peak; ctx.fillStyle = mountainBaseColor; ctx.beginPath(); ctx.moveTo(mountain.x, mountain.y + mountain.height); ctx.lineTo(mountain.x + mountain.width / 2, mountain.y); ctx.lineTo(mountain.x + mountain.width, mountain.y + mountain.height); ctx.closePath(); ctx.fill(); ctx.fillStyle = mountainPeakColor; mountain.peaks.forEach(peak => { const peakX = mountain.x + peak.xRatio * mountain.width; const peakBaseYOnSlope = mountain.y + peak.baseYRatio * mountain.height; const currentPeakHeight = peak.heightRatio * mountain.height; if (peakBaseYOnSlope - currentPeakHeight > mountain.y && peakBaseYOnSlope < mountain.y + mountain.height * 0.85) { ctx.beginPath(); ctx.moveTo(peakX - mountain.width * 0.03, peakBaseYOnSlope); ctx.lineTo(peakX, peakBaseYOnSlope - currentPeakHeight + peak.yOffset); ctx.lineTo(peakX + mountain.width * 0.03, peakBaseYOnSlope); ctx.closePath(); ctx.fill(); } }); });
            const celestialX = canvas.width*0.8, celestialY = canvas.height*0.15, celestialRadius = 12*PIXEL_SCALE; // Smaller sun
            ctx.fillStyle = isDayTime ? currentEnv.sun : currentEnv.moon;
            if(isDayTime) ctx.globalAlpha = 0.8; // Subdued sun
            ctx.beginPath(); ctx.arc(celestialX, celestialY, celestialRadius, 0, Math.PI*2); ctx.fill();
            ctx.globalAlpha = 1.0;
            if(isDayTime && currentEnv.sun_rays){ ctx.fillStyle = currentEnv.sun_rays; for(let i=0; i<12; i++){ ctx.save(); ctx.translate(celestialX, celestialY); ctx.rotate(i * Math.PI / 6); ctx.fillRect(celestialRadius * 1.1, -1 * PIXEL_SCALE, celestialRadius * 0.8, 2 * PIXEL_SCALE); ctx.restore(); } } else if (!isDayTime && nightEnvironmentColors.moon_glow) { const glowGrad = ctx.createRadialGradient(celestialX, celestialY, celestialRadius * 0.8, celestialX, celestialY, celestialRadius * 3); glowGrad.addColorStop(0, nightEnvironmentColors.moon_glow); glowGrad.addColorStop(1, 'rgba(220, 220, 255, 0)'); ctx.fillStyle = glowGrad; ctx.fillRect(0,0, canvas.width, canvas.height); }
            distantCastles.forEach(castle => { ctx.fillStyle = isDayTime ? currentEnv.castle_silhouette : nightEnvironmentColors.castle_silhouette; ctx.fillRect(castle.x, castle.y, castle.width, castle.height); castle.towers.forEach(tower => { ctx.fillStyle = isDayTime ? currentEnv.castle_tower : nightEnvironmentColors.castle_tower; ctx.fillRect(castle.x + tower.xOffset, castle.y - tower.height * 0.3, tower.width, tower.height); if (tower.roofType === 'conical') { ctx.fillStyle = isDayTime ? currentEnv.castle_roof : nightEnvironmentColors.castle_roof; ctx.beginPath(); ctx.moveTo(castle.x + tower.xOffset, castle.y - tower.height * 0.3); ctx.lineTo(castle.x + tower.xOffset + tower.width / 2, castle.y - tower.height * 0.3 - tower.width * 0.4); ctx.lineTo(castle.x + tower.xOffset + tower.width, castle.y - tower.height * 0.3); ctx.closePath(); ctx.fill(); } else if (tower.roofType === 'domed') { ctx.fillStyle = isDayTime ? currentEnv.castle_roof : nightEnvironmentColors.castle_roof; ctx.beginPath(); ctx.arc(castle.x + tower.xOffset + tower.width/2, castle.y - tower.height * 0.3, tower.width/2, Math.PI, 0); ctx.fill();} else { ctx.fillStyle = isDayTime ? currentEnv.castle_battlement : nightEnvironmentColors.castle_battlement; ctx.fillRect(castle.x + tower.xOffset, castle.y - tower.height * 0.3 - 3 * PIXEL_SCALE, tower.width, 3 * PIXEL_SCALE); for(let k=0; k < tower.width / (5*PIXEL_SCALE); k++){ ctx.fillRect(castle.x + tower.xOffset + k*5*PIXEL_SCALE, castle.y - tower.height*0.3 - 6*PIXEL_SCALE, 3*PIXEL_SCALE, 3*PIXEL_SCALE); } } }); if (!isDayTime) { ctx.fillStyle = nightEnvironmentColors.castle_light; castle.lights.forEach(light => { ctx.fillRect(light.x, light.y, light.w, light.h); }); } });
            if (!isDayTime) { ctx.fillStyle = '#FFFFFF'; defenseStars.forEach(star => { ctx.globalAlpha = star.opacity; ctx.fillRect(star.x, star.y, star.size, star.size); ctx.globalAlpha = 1.0;}); }
            ctx.fillStyle = currentEnv.forest_far; farForestTrees.forEach(tree => { ctx.beginPath(); if(tree.type === 'pine'){ ctx.moveTo(tree.x + tree.width/2, tree.baseY - tree.height); ctx.lineTo(tree.x, tree.baseY - tree.height*0.3); ctx.lineTo(tree.x + tree.width*0.3, tree.baseY - tree.height*0.4); ctx.lineTo(tree.x + tree.width*0.2, tree.baseY - tree.height*0.1); ctx.lineTo(tree.x + tree.width*0.8, tree.baseY - tree.height*0.1); ctx.lineTo(tree.x + tree.width*0.7, tree.baseY - tree.height*0.4); ctx.lineTo(tree.x + tree.width, tree.baseY - tree.height*0.3); } else { ctx.ellipse(tree.x + tree.width/2, tree.baseY - tree.height*0.6, tree.width*0.55, tree.height*0.45, 0, 0, Math.PI*2);} ctx.closePath();ctx.fill(); });
            ctx.fillStyle = currentEnv.forest_mid; midForestTrees.forEach(tree => { ctx.beginPath(); if(tree.type === 'pine'){ctx.moveTo(tree.x + tree.width*0.5, tree.baseY - tree.height); ctx.lineTo(tree.x, tree.baseY - tree.height*0.2); ctx.lineTo(tree.x + tree.width, tree.baseY - tree.height*0.2); } else { ctx.ellipse(tree.x + tree.width/2, tree.baseY - tree.height*0.5, tree.width*0.65, tree.height*0.55, 0,0, Math.PI*2); } ctx.closePath();ctx.fill(); });
            ctx.fillStyle = currentEnv.forest_near; ctx.fillRect(0,canvas.height*0.75,canvas.width,canvas.height*0.25);
            pathTextureElements.forEach(p => { ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, p.w, p.h); });
            parapetStones.forEach(stone => { ctx.fillStyle = stone.color; ctx.fillRect(stone.x, stone.y, stone.sizeW, stone.sizeH); });
            const parapetHeight = 30 * PIXEL_SCALE; for(let i=0; i < canvas.width / (20*PIXEL_SCALE); i++){ ctx.fillStyle=commonEnvironmentColors.tower_stone_highlight; const crenH = (10)*PIXEL_SCALE; const crenW = 10*PIXEL_SCALE; ctx.fillRect(i*20*PIXEL_SCALE + 5*PIXEL_SCALE, canvas.height-parapetHeight-crenH, crenW, crenH); ctx.fillStyle=commonEnvironmentColors.tower_stone_darker; ctx.fillRect(i*20*PIXEL_SCALE + 5*PIXEL_SCALE, canvas.height-parapetHeight-crenH + crenH - PIXEL_SCALE*2, crenW, PIXEL_SCALE*2); }
            defensePaviseShields.forEach(shield => { drawPaviseShield(ctx, shield.x, shield.y, shield.width, shield.height, shield.angle); });
            const crossbowAngle = Math.atan2(mouseY - player.y, mouseX - player.x);
            drawBertold(ctx, player.x, player.y, PIXEL_SCALE, crossbowAngle, false, true);
            const spareCbX = 20 * PIXEL_SCALE; const spareCbY = canvas.height - parapetHeight - 25 * PIXEL_SCALE; ctx.save(); ctx.translate(spareCbX, spareCbY); ctx.rotate(0.3); ctx.fillStyle = bertoldColors.wood; ctx.fillRect(-8*PIXEL_SCALE, -2.5*PIXEL_SCALE, 16*PIXEL_SCALE, 5*PIXEL_SCALE); ctx.fillStyle = bertoldColors.armor; ctx.fillRect(4*PIXEL_SCALE, -7*PIXEL_SCALE, 4*PIXEL_SCALE, 14*PIXEL_SCALE); ctx.fillStyle = bertoldColors.string; ctx.lineWidth=PIXEL_SCALE; ctx.beginPath(); ctx.moveTo(4*PIXEL_SCALE, -7*PIXEL_SCALE); ctx.lineTo(4*PIXEL_SCALE, 7*PIXEL_SCALE); ctx.stroke(); ctx.restore();
            const barrelX = canvas.width - 40 * PIXEL_SCALE; const barrelY = canvas.height - parapetHeight - 15 * PIXEL_SCALE; const barrelRadius = 8 * PIXEL_SCALE; ctx.fillStyle = commonEnvironmentColors.tower_wood_dark; ctx.beginPath(); ctx.ellipse(barrelX, barrelY, barrelRadius, barrelRadius * 0.8, 0, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = '#3a2e20'; ctx.fillRect(barrelX - barrelRadius, barrelY - barrelRadius*0.45, barrelRadius*2, 2.5*PIXEL_SCALE); ctx.fillRect(barrelX - barrelRadius, barrelY + barrelRadius*0.25, barrelRadius*2, 2.5*PIXEL_SCALE); ctx.fillStyle = '#D2B48C'; for(let i=0; i<7; i++) { ctx.fillRect(barrelX - barrelRadius/2 + (Math.random()*barrelRadius - barrelRadius/2), barrelY - barrelRadius*0.8 - Math.random()*7*PIXEL_SCALE, 1.5*PIXEL_SCALE, 8*PIXEL_SCALE); }
            ctx.fillStyle = commonEnvironmentColors.tower_stone_darker; ctx.fillRect(60*PIXEL_SCALE, canvas.height - parapetHeight + 5*PIXEL_SCALE, 7*PIXEL_SCALE, 5*PIXEL_SCALE); ctx.fillRect(65*PIXEL_SCALE, canvas.height - parapetHeight + 10*PIXEL_SCALE, 5*PIXEL_SCALE, 6*PIXEL_SCALE); ctx.fillStyle = commonEnvironmentColors.tower_stone; ctx.fillRect(canvas.width - 70*PIXEL_SCALE, canvas.height - parapetHeight + 3*PIXEL_SCALE, 8*PIXEL_SCALE, 8*PIXEL_SCALE);
        }
        function drawBertold(ctx, x, y, scale, angle, isIdle, isDefenseScreen) {
            const s = scale;
            ctx.save();
            ctx.translate(x, y);

            const headRadius = 4 * s;
            const torsoHeight = 14 * s;
            const torsoWidth = 9 * s;
            const legHeight = 11 * s;
            const legWidth = 4 * s;
            const armLength = 10 * s;
            const armWidth = 3.5 * s;
            const footHeight = 2.5 * s;
            const footWidth = 4.5 * s;
            const neckHeight = 1.5 * s;
            const capeWidth = torsoWidth * 1.6;
            const capeLength = torsoHeight + legHeight * 0.9;
            const helmetHeight = headRadius * 1.8;
            const helmetWidth = headRadius * 2.4;

            let feetBaseY = isDefenseScreen ? (12 * s) : 0;
            let bodyCenterX = 0;
            if (isDefenseScreen) {
                 bodyCenterX = - (torsoWidth / 2 + 1 * s) * Math.cos(angle + Math.PI / 2);
                 feetBaseY += (12*s) - (torsoHeight/2) - helmetHeight/2 - neckHeight + 6*s;
            }
            ctx.translate(bodyCenterX,0);

            ctx.fillStyle = bertoldColors.cape;
            ctx.beginPath();
            if (isDefenseScreen) {
                const capeOffsetX = Math.sin(angle) * 6 * s;
                const capeShoulderY = feetBaseY - legHeight - torsoHeight*0.9;
                ctx.moveTo(-capeWidth/2 + capeOffsetX, capeShoulderY);
                ctx.lineTo(capeWidth/2 + capeOffsetX, capeShoulderY);
                ctx.quadraticCurveTo(capeWidth*0.4 + capeOffsetX, feetBaseY + capeLength*0.1, capeWidth*0.1 + capeOffsetX, feetBaseY + capeLength*0.4);
                ctx.lineTo(-capeWidth*0.1 + capeOffsetX, feetBaseY + capeLength*0.4);
                ctx.quadraticCurveTo(-capeWidth*0.4 + capeOffsetX, feetBaseY + capeLength*0.1, -capeWidth/2 + capeOffsetX, capeShoulderY);
            } else {
                const capeShoulderY = feetBaseY - legHeight - torsoHeight*0.9;
                ctx.moveTo(-capeWidth/2, capeShoulderY);
                ctx.lineTo(capeWidth/2, capeShoulderY);
                ctx.lineTo(capeWidth*0.3, feetBaseY + capeLength*0.4);
                ctx.lineTo(-capeWidth*0.3, feetBaseY + capeLength*0.4);
            }
            ctx.closePath();
            ctx.fill();


            ctx.fillStyle = bertoldColors.cloth;
            ctx.fillRect(-torsoWidth/2 + legWidth/2, feetBaseY - legHeight - footHeight, legWidth, legHeight);
            ctx.fillRect(torsoWidth/2 - legWidth*1.5, feetBaseY - legHeight - footHeight, legWidth, legHeight);
            ctx.fillStyle = bertoldColors.boots;
            ctx.fillRect(-torsoWidth/2, feetBaseY - footHeight, footWidth, footHeight);
            ctx.fillRect(torsoWidth/2 - footWidth, feetBaseY - footHeight, footWidth, footHeight);

            const torsoY = feetBaseY - legHeight - footHeight - torsoHeight;
            ctx.fillStyle = bertoldColors.cloth;
            ctx.fillRect(-torsoWidth/2, torsoY, torsoWidth, torsoHeight);
            ctx.fillStyle = bertoldColors.belt;
            ctx.fillRect(-torsoWidth/2 - 0.5*s, torsoY + torsoHeight*0.4, torsoWidth + 1*s, 2.5*s);
            ctx.fillStyle = bertoldColors.trim;
            ctx.fillRect(-1.5*s, torsoY + torsoHeight*0.4 + 0.5*s, 3*s, 1.5*s);

            ctx.fillStyle = bertoldColors.armor;
            ctx.fillRect(-torsoWidth/2 + 1*s, torsoY + 1*s, torsoWidth - 2*s, torsoHeight - 2.5*s);


            const shoulderY = torsoY + 1.5*s;
            if (isIdle) {
                ctx.fillStyle = bertoldColors.cloth;
                ctx.fillRect(-torsoWidth/2 - armWidth, shoulderY, armWidth, armLength);
                ctx.fillRect(torsoWidth/2, shoulderY, armWidth, armLength);
                ctx.fillStyle = bertoldColors.skin;
                ctx.fillRect(-torsoWidth/2 - armWidth, shoulderY + armLength, armWidth, 2*s);
                ctx.fillRect(torsoWidth/2, shoulderY + armLength, armWidth, 2*s);
            } else {
                ctx.save();
                const armAttachX = 0;
                const armAttachY = shoulderY + armLength * 0.2;
                ctx.fillStyle = bertoldColors.cloth;
                // Left Arm
                ctx.beginPath(); ctx.moveTo(armAttachX - torsoWidth*0.4, armAttachY); ctx.lineTo(armAttachX - torsoWidth*0.4 - Math.cos(angle + Math.PI/4)*armLength*0.6, armAttachY - Math.sin(angle + Math.PI/4)*armLength*0.6); ctx.lineTo(armAttachX - torsoWidth*0.4 - Math.cos(angle + Math.PI/4)*armLength*0.6 + armWidth, armAttachY - Math.sin(angle + Math.PI/4)*armLength*0.6); ctx.lineTo(armAttachX - torsoWidth*0.4 + armWidth, armAttachY); ctx.closePath(); ctx.fill();
                // Right Arm
                ctx.beginPath(); ctx.moveTo(armAttachX + torsoWidth*0.4, armAttachY); ctx.lineTo(armAttachX + torsoWidth*0.4 - Math.cos(angle - Math.PI/4)*armLength*0.6, armAttachY - Math.sin(angle - Math.PI/4)*armLength*0.6); ctx.lineTo(armAttachX + torsoWidth*0.4 - Math.cos(angle - Math.PI/4)*armLength*0.6 - armWidth, armAttachY - Math.sin(angle - Math.PI/4)*armLength*0.6); ctx.lineTo(armAttachX + torsoWidth*0.4 - armWidth, armAttachY); ctx.closePath(); ctx.fill();
                ctx.restore();
                 if(player.isReloading){
                    ctx.save();
                    ctx.translate(0, torsoY + torsoHeight * 0.5);
                    ctx.rotate(Math.PI / 6);
                    ctx.fillStyle = bertoldColors.wood;
                    ctx.fillRect(-5*s, -1*s, 10*s, 2*s);
                    ctx.restore();
                }
            }

            const headY = torsoY - helmetHeight/2 - neckHeight + headRadius*0.2;
            ctx.fillStyle = bertoldColors.skin;
            ctx.fillRect(-1.5*s, torsoY - neckHeight, 3*s, neckHeight);

            ctx.save();
            if (isDefenseScreen) {
                let headAngle = angle - Math.PI/2;
                const maxHeadTurn = Math.PI / 6;
                if (Math.abs(headAngle) > maxHeadTurn) headAngle = Math.sign(headAngle) * maxHeadTurn;
                ctx.rotate(headAngle);
            }

            ctx.fillStyle = bertoldColors.helmet_metal;
            ctx.beginPath(); ctx.ellipse(0, headY - headRadius*0.3, helmetWidth/2, helmetHeight/2, 0, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.moveTo(-helmetWidth*0.3, headY - headRadius*0.1); ctx.lineTo(helmetWidth*0.3, headY - headRadius*0.1); ctx.lineTo(helmetWidth*0.2, headY + headRadius*0.5); ctx.lineTo(-helmetWidth*0.2, headY + headRadius*0.5); ctx.closePath(); ctx.fill();
            ctx.fillStyle = bertoldColors.helmet_metal; ctx.beginPath(); ctx.moveTo(-helmetWidth*0.4, headY + headRadius*0.3); ctx.lineTo(helmetWidth*0.4, headY + headRadius*0.3); ctx.lineTo(helmetWidth*0.3, headY + headRadius*0.8); ctx.lineTo(-helmetWidth*0.3, headY + headRadius*0.8); ctx.closePath(); ctx.fill();
            ctx.fillStyle = bertoldColors.helmet_trim;
            ctx.fillRect(-helmetWidth/2, headY - headRadius*0.3 - s/2, helmetWidth, s);
            ctx.fillRect(-s/2, headY - headRadius*0.3 - helmetHeight/2 + s, s, helmetHeight - 2*s);

            ctx.fillStyle = bertoldColors.skin; ctx.fillRect(-headRadius*0.5, headY, headRadius, headRadius*0.6);
            ctx.fillStyle = bertoldColors.eye; ctx.fillRect(-headRadius*0.3, headY + headRadius*0.1, 1*s, 1*s); ctx.fillRect(headRadius*0.05, headY + headRadius*0.1, 1*s, 1*s);

            ctx.restore();
            ctx.restore();
        }
        function drawPaviseShield(ctx, x, y, width, height, angle) {
            ctx.save();
            ctx.translate(x + width/2, y + height/2);
            ctx.rotate(angle);
            ctx.fillStyle = commonEnvironmentColors.pavise_wood; ctx.fillRect(-width/2, -height/2, width, height);
            ctx.strokeStyle = commonEnvironmentColors.pavise_border; ctx.lineWidth = PIXEL_SCALE * 1.5; ctx.strokeRect(-width/2, -height/2, width, height);
            ctx.fillStyle = commonEnvironmentColors.pavise_cross; const crossArmWidth = width * 0.15; const crossArmHeight = height * 0.4;
            ctx.fillRect(-crossArmWidth/2, -crossArmHeight/2, crossArmWidth, crossArmHeight);
            ctx.fillRect(-crossArmHeight/2, -crossArmWidth/2, crossArmHeight, crossArmWidth);
            ctx.restore();
        }


        function drawPlayerCrossbow() { const angle = Math.atan2(mouseY - player.y, mouseX - player.x); ctx.save(); ctx.translate(player.x, player.y); ctx.rotate(angle); const cb = player.equippedCrossbow; ctx.fillStyle = cb.wood || bertoldColors.wood; ctx.fillRect(-7*PIXEL_SCALE, -3*PIXEL_SCALE, 14*PIXEL_SCALE, 6*PIXEL_SCALE); ctx.fillStyle = cb.metal || bertoldColors.armor; ctx.fillRect(4*PIXEL_SCALE, -8*PIXEL_SCALE, 5*PIXEL_SCALE, 16*PIXEL_SCALE); ctx.restore(); }
        function drawBolt(bolt) { ctx.save(); ctx.translate(bolt.x, bolt.y); ctx.rotate(bolt.rotation); const shaftColor = bolt.isFlaming ? commonEnvironmentColors.fire_orange : '#5D4037'; const headColor = bolt.isFlaming ? commonEnvironmentColors.fire_red : '#9E9E9E'; const fletchingColor = bolt.isFlaming ? commonEnvironmentColors.fire_yellow : '#A1887F'; ctx.fillStyle = shaftColor; ctx.fillRect(-4*PIXEL_SCALE, -0.5*PIXEL_SCALE, 6*PIXEL_SCALE, 1*PIXEL_SCALE); ctx.fillStyle = headColor; ctx.beginPath(); ctx.moveTo(2*PIXEL_SCALE,0); ctx.lineTo(0*PIXEL_SCALE, -1.5*PIXEL_SCALE); ctx.lineTo(0*PIXEL_SCALE, 1.5*PIXEL_SCALE); ctx.closePath(); ctx.fill(); ctx.strokeStyle = fletchingColor; ctx.lineWidth = 0.5*PIXEL_SCALE; ctx.beginPath(); ctx.moveTo(-4*PIXEL_SCALE,0); ctx.lineTo(-5*PIXEL_SCALE, -1*PIXEL_SCALE); ctx.moveTo(-4*PIXEL_SCALE,0); ctx.lineTo(-5*PIXEL_SCALE, 1*PIXEL_SCALE); ctx.stroke(); if(bolt.isFlaming && frameCount % 3 < 2) { ctx.fillStyle = Math.random() > 0.5 ? commonEnvironmentColors.fire_orange : commonEnvironmentColors.fire_yellow; ctx.fillRect(2*PIXEL_SCALE, -1*PIXEL_SCALE, 2*PIXEL_SCALE, 2*PIXEL_SCALE); } ctx.restore(); }
        function drawGhoulBolt(gBolt) {
            ctx.fillStyle = ghulColors.projectile;
            ctx.beginPath();
            ctx.arc(gBolt.x, gBolt.y, gBolt.width, 0, Math.PI * 2);
            ctx.fill();
        }
        function drawBossProjectile(bp) {
            ctx.fillStyle = bp.color;
            ctx.beginPath();
            const pulseFactor = 1 + Math.sin(frameCount * 0.2) * 0.2;
            ctx.arc(bp.x, bp.y, bp.width * pulseFactor, 0, Math.PI * 2);
            ctx.fill();
        }
        function drawOilSpill(oil) {
            const spillColor = `rgba(50, 30, 10, ${0.3 + (oil.duration / 5.0) * 0.4})`;
            ctx.fillStyle = spillColor;
            ctx.fillRect(oil.x, oil.y, oil.width, oil.height);
            if (frameCount % 5 < 3) {
                for(let i=0; i<3; i++){
                    ctx.fillStyle = Math.random() > 0.5 ? commonEnvironmentColors.fire_orange : commonEnvironmentColors.fire_red;
                    ctx.fillRect(oil.x + Math.random()*oil.width, oil.y + Math.random()*oil.height - 2*PIXEL_SCALE, 2*PIXEL_SCALE, 2*PIXEL_SCALE);
                }
            }
        }
        function drawEnemy(enemy, isDayTime) {
            if (enemy.dyingTimer > 0) {
                const alpha = enemy.dyingTimer / 0.5;
                ctx.globalAlpha = alpha;
                const shrinkFactor = 1 - (0.5 - enemy.dyingTimer) / 0.5;
                const drawX = enemy.x + (enemy.width * (1 - shrinkFactor)) / 2;
                const drawY = enemy.y + (enemy.height * (1 - shrinkFactor)) / 2;
                const drawW = enemy.width * shrinkFactor;
                const drawH = enemy.height * shrinkFactor;
                let currentSkinColor = ghulColors.skin; let currentRagColor = ghulColors.rags; if(isDayTime){ currentSkinColor = '#a8c0a6'; currentRagColor = '#555555'; } ctx.fillStyle=currentSkinColor; ctx.fillRect(drawX,drawY,drawW,drawH); ctx.fillRect(drawX+PIXEL_SCALE,drawY-4*PIXEL_SCALE*shrinkFactor,drawW-2*PIXEL_SCALE,5*PIXEL_SCALE*shrinkFactor); ctx.fillStyle=ghulColors.eyes; ctx.fillRect(drawX+2*PIXEL_SCALE,drawY-3*PIXEL_SCALE*shrinkFactor,1.5*PIXEL_SCALE*shrinkFactor,1.5*PIXEL_SCALE*shrinkFactor); ctx.fillRect(drawX+drawW-3.5*PIXEL_SCALE*shrinkFactor,drawY-3*PIXEL_SCALE*shrinkFactor,1.5*PIXEL_SCALE*shrinkFactor,1.5*PIXEL_SCALE*shrinkFactor); ctx.fillStyle=currentRagColor; ctx.fillRect(drawX+PIXEL_SCALE,drawY+drawH*0.5,drawW-2*PIXEL_SCALE,drawH*0.5); ctx.fillStyle=currentSkinColor; ctx.fillRect(drawX-2*PIXEL_SCALE*shrinkFactor,drawY+drawH*0.3,2*PIXEL_SCALE*shrinkFactor,drawH*0.4); ctx.fillRect(drawX+drawW,drawY+drawH*0.3,2*PIXEL_SCALE*shrinkFactor,drawH*0.4);
                ctx.globalAlpha = 1.0;
                return;
            }

            let currentSkinColor = ghulColors.skin; let currentRagColor = ghulColors.rags;
            if(enemy.type === 'armored') currentSkinColor = '#505060';
            else if(enemy.type === 'skirmisher') currentSkinColor = '#80a080';
            else if(enemy.type === 'ranged') currentSkinColor = '#a080a0';

            if(isDayTime && enemy.type !== 'armored'){ currentSkinColor = '#a8c0a6'; currentRagColor = '#555555'; }

            ctx.fillStyle=currentSkinColor; ctx.fillRect(enemy.x,enemy.y,enemy.width,enemy.height);
            ctx.fillRect(enemy.x+PIXEL_SCALE,enemy.y-4*PIXEL_SCALE,enemy.width-2*PIXEL_SCALE,5*PIXEL_SCALE);
            ctx.fillStyle=ghulColors.eyes; ctx.fillRect(enemy.x+2*PIXEL_SCALE,enemy.y-3*PIXEL_SCALE,1.5*PIXEL_SCALE,1.5*PIXEL_SCALE); ctx.fillRect(enemy.x+enemy.width-3.5*PIXEL_SCALE,enemy.y-3*PIXEL_SCALE,1.5*PIXEL_SCALE,1.5*PIXEL_SCALE);
            ctx.fillStyle=currentRagColor; ctx.fillRect(enemy.x+PIXEL_SCALE,enemy.y+enemy.height*0.5,enemy.width-2*PIXEL_SCALE,enemy.height*0.5);
            ctx.fillStyle=currentSkinColor; ctx.fillRect(enemy.x-2*PIXEL_SCALE,enemy.y+enemy.height*0.3,2*PIXEL_SCALE,enemy.height*0.4); ctx.fillRect(enemy.x+enemy.width,enemy.y+enemy.height*0.3,2*PIXEL_SCALE,enemy.height*0.4);
            if(enemiesFrozen) { ctx.fillStyle = 'rgba(100, 150, 255, 0.4)'; ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);}
        }
        function drawBoss(bossData, isDayTime) {
            if (bossData.dyingTimer > 0) {
                const alpha = bossData.dyingTimer / 1.0;
                ctx.globalAlpha = alpha;
                const shrinkFactor = 1 - (1.0 - bossData.dyingTimer) / 1.0;
                const drawX = bossData.x + (bossData.width * (1 - shrinkFactor)) / 2;
                const drawY = bossData.y + (bossData.height * (1 - shrinkFactor)) / 2;
                const drawW = bossData.width * shrinkFactor;
                const drawH = bossData.height * shrinkFactor;
                const bossColor = isDayTime ? '#504030' : '#302010'; ctx.fillStyle = bossColor; ctx.fillRect(drawX, drawY, drawW, drawH);
                ctx.globalAlpha = 1.0;
                return;
            }

            const bossColor = isDayTime ? '#504030' : '#302010';
            const eyeColor = '#FF0000';
            const hornColor = isDayTime ? '#C0C0C0' : '#A0A0A0';

            ctx.fillStyle = bossColor;
            ctx.fillRect(bossData.x, bossData.y, bossData.width, bossData.height);
            ctx.fillRect(bossData.x + bossData.width * 0.2, bossData.y - bossData.height * 0.2, bossData.width * 0.6, bossData.height * 0.3);
            ctx.fillStyle = eyeColor;
            ctx.fillRect(bossData.x + bossData.width * 0.3, bossData.y - bossData.height * 0.15, PIXEL_SCALE * 3, PIXEL_SCALE * 3);
            ctx.fillRect(bossData.x + bossData.width * 0.7 - PIXEL_SCALE * 3, bossData.y - bossData.height * 0.15, PIXEL_SCALE * 3, PIXEL_SCALE * 3);
            ctx.fillStyle = hornColor;
            ctx.beginPath(); ctx.moveTo(bossData.x + bossData.width * 0.25, bossData.y - bossData.height * 0.2); ctx.lineTo(bossData.x + bossData.width * 0.15, bossData.y - bossData.height * 0.4); ctx.lineTo(bossData.x + bossData.width * 0.35, bossData.y - bossData.height * 0.25); ctx.closePath(); ctx.fill();
            ctx.beginPath(); ctx.moveTo(bossData.x + bossData.width * 0.75, bossData.y - bossData.height * 0.2); ctx.lineTo(bossData.x + bossData.width * 0.85, bossData.y - bossData.height * 0.4); ctx.lineTo(bossData.x + bossData.width * 0.65, bossData.y - bossData.height * 0.25); ctx.closePath(); ctx.fill();
            ctx.fillStyle = bossColor;
            ctx.fillRect(bossData.x - bossData.width * 0.1, bossData.y + bossData.height * 0.3, bossData.width * 0.3, bossData.height * 0.2);
            ctx.fillRect(bossData.x + bossData.width * 0.8, bossData.y + bossData.height * 0.3, bossData.width * 0.3, bossData.height * 0.2);

            if(enemiesFrozen) { ctx.fillStyle = 'rgba(100, 150, 255, 0.4)'; ctx.fillRect(bossData.x, bossData.y, bossData.width, bossData.height); }
        }
        function drawGameOverScreen() {  ctx.fillStyle="rgba(0,0,0,0.75)"; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.font=`bold ${10*PIXEL_SCALE}px 'Courier New',monospace`; ctx.fillStyle='#b71c1c'; ctx.textAlign='center'; ctx.fillText("DEFEATED",canvas.width/2,canvas.height/2-35*PIXEL_SCALE); ctx.font=`${4*PIXEL_SCALE}px 'Courier New',monospace`; ctx.fillStyle='#e0dacd'; ctx.fillText(lastMessage,canvas.width/2,canvas.height/2+15*PIXEL_SCALE); ctx.fillText(`Final Score: ${score}`,canvas.width/2,canvas.height/2+40*PIXEL_SCALE); ctx.fillText(`Survived ${wave} Waves`,canvas.width/2,canvas.height/2+60*PIXEL_SCALE); }
        function drawVictoryScreen() { ctx.fillStyle="rgba(50,100,50,0.75)"; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.font=`bold ${12*PIXEL_SCALE}px 'Courier New',monospace`; ctx.fillStyle=bertoldColors.trim; ctx.textAlign='center'; ctx.fillText("VICTORY!",canvas.width/2,canvas.height/3); ctx.font=`${6*PIXEL_SCALE}px 'Courier New',monospace`; ctx.fillStyle='#e0dacd'; ctx.fillText("Jer'Ghuul is Vanquished! Bertold's Watch is safe!",canvas.width/2,canvas.height/2); ctx.fillText(`Final Score: ${score}`,canvas.width/2,canvas.height/2+30*PIXEL_SCALE); ctx.fillText(`You survived all ${MAX_WAVES + 1} challenges!`,canvas.width/2,canvas.height/2+50*PIXEL_SCALE); }

        function startReload() {  player.isReloading = true; player.reloadTimer = player.equippedCrossbow.reloadTime; reloadIndicator.style.display = 'block'; playSound('reload_start'); showMessage(`Reloading (${player.equippedCrossbow.reloadTime.toFixed(1)}s)...`, player.equippedCrossbow.reloadTime*1000-100); }
        function shootBolt() {
            const cb = player.equippedCrossbow;
            const speed = cb.boltSpeed * PIXEL_SCALE;
            const baseAngle = Math.atan2(mouseY-player.y, mouseX-player.x);
            const isLegendaryFlaming = cb.mechanic && cb.mechanic.includes('flaming');
            const isUpgradedFlaming = player.hasFlamingArrowsUpgrade && !isLegendaryFlaming;
            let actualDamage = cb.damage;
            if(isUpgradedFlaming) actualDamage += 5;
            playSound('crossbow_fire');

            const createBolt = (angleOffset = 0) => {
                const angle = baseAngle + angleOffset;
                bolts.push({
                    x:player.x, y:player.y,
                    width:6*PIXEL_SCALE, height:1.5*PIXEL_SCALE,
                    vx:Math.cos(angle)*speed, vy:Math.sin(angle)*speed,
                    damage:actualDamage, rotation: angle,
                    isFlaming: isLegendaryFlaming || isUpgradedFlaming,
                    pierceCount: player.hasPiercingBoltsUpgrade ? 1 : 0
                });
            };
            if (cb.mechanic === 'multishot_2') { createBolt(-BOLT_SPREAD_ANGLE / 2); createBolt(BOLT_SPREAD_ANGLE / 2); }
            else if (cb.mechanic === 'multishot_3_flaming') { createBolt(-BOLT_SPREAD_ANGLE); createBolt(0); createBolt(BOLT_SPREAD_ANGLE); }
            else { createBolt(0); }
        }
        function spawnEnemy(typeOverride = null) {
            if(enemiesToSpawnThisWave<=0 && !typeOverride)return;
            const baseSizeValue = Math.random()*6+9;
            let enemyType = typeOverride;
            if(!enemyType){
                const typeRand = Math.random();
                if (wave > 2 && typeRand < 0.2) enemyType = 'armored';
                else if (wave > 1 && typeRand < 0.4) enemyType = 'skirmisher';
                else if (wave > 3 && typeRand < 0.55) enemyType = 'ranged';
                else enemyType = 'normal';
            }

            const diffSetting = difficultySettings[difficulty];
            const enemy = {
                id: Date.now() + Math.random(),
                type: enemyType,
                x:Math.random()*(canvas.width - baseSizeValue*PIXEL_SCALE),
                y:-baseSizeValue*PIXEL_SCALE * 1.1,
                width: baseSizeValue*PIXEL_SCALE,
                height: baseSizeValue*PIXEL_SCALE * 1.1,
                speed:( (Math.random()*15+15+(wave*2))*PIXEL_SCALE ) * 0.9 * 0.8 * 0.8 * diffSetting.speedFactor,
                health: 0,
                maxHealth: 0,
                attackTimer: 0,
                attackCooldown: 2 + Math.random() * 2,
                dyingTimer: 0,
                hitByStakes: false
            };

            switch(enemyType) {
                case 'armored':
                    enemy.health = (40 + wave * 2) * diffSetting.healthFactor;
                    enemy.speed *= 0.7;
                    enemy.color = '#505060';
                    break;
                case 'skirmisher':
                    enemy.health = (15 + wave) * diffSetting.healthFactor;
                    enemy.speed *= 1.5;
                    enemy.width *= 0.8; enemy.height *= 0.8;
                    enemy.color = '#80a080';
                    break;
                case 'ranged':
                    enemy.health = (20 + wave) * diffSetting.healthFactor;
                    enemy.speed *= 0.8;
                    enemy.stopDistance = canvas.height * (0.3 + Math.random() * 0.2);
                    enemy.color = '#a080a0';
                    break;
                default:
                    if (baseSizeValue < 11) enemy.health = 10;
                    else if (baseSizeValue < 13) enemy.health = 20;
                    else enemy.health = 30;
                    enemy.health *= diffSetting.healthFactor;
                    enemy.color = ghulColors.skin;
                    break;
            }
            enemy.maxHealth = enemy.health;
            enemies.push(enemy);
            if(!typeOverride) enemiesToSpawnThisWave--;
            lastEnemySpawnTime=Date.now();
        }
        function spawnBoss() {
            const bossSizeFactor = 2.5;
            const bossHealth = (750 + wave * 75) * difficultySettings[difficulty].bossHealthFactor;
            return {
                id: 'jerghuul', name: "Jer'Ghuul The Dark",
                x: canvas.width / 2 - (15 * PIXEL_SCALE * bossSizeFactor) / 2,
                y: -30 * PIXEL_SCALE * bossSizeFactor,
                width: 15 * PIXEL_SCALE * bossSizeFactor,
                height: 20 * PIXEL_SCALE * bossSizeFactor,
                speed: ( (10 + wave * 0.2) * PIXEL_SCALE * 0.6 ) * difficultySettings[difficulty].speedFactor,
                health: bossHealth, maxHealth: bossHealth,
                damageToTower: 50,
                color: ghulColors.skin,
                summonedAt75: false, summonedAt50: false, summonedAt25: false,
                dyingTimer: 0,
                attackTimer: 3,
                attackCooldown: 4 + Math.random() * 2
            };
        }
        function gameOver(message) { playSound('game_over_sound'); gameState='GAME_OVER';lastMessage=message;if(gameLoopRequestId)cancelAnimationFrame(gameLoopRequestId);updateControls();draw(); }
        function populateShop() {
            shopItems = [];
            const rarityOrder = ["Uncommon", "Rare", "Epic", "Legendary"];
            const slotCosts = [100, 300, 500, 1000];

            const shopUpgrades = [
                { id: 'flaming_arrows_upgrade', name: "Enchant: Flaming Arrows", rarity: "Upgrade", color: commonEnvironmentColors.fire_orange, description: "Bolts gain +5 Fire Dmg.", displayCost: 125, isUpgrade: true, isPlayerUpgrade: true, flag: 'hasFlamingArrowsUpgrade'},
                { id: 'piercing_bolts_upgrade', name: "Fletching: Bodkin Bolts", rarity: "Upgrade", color: bertoldColors.trim, description: "Bolts can pierce one enemy.", displayCost: 125, isUpgrade: true, isPlayerUpgrade: true, flag: 'hasPiercingBoltsUpgrade'},
                { id: 'tower_reinforce_1', name: "Tower Reinforcement", rarity: "Upgrade", color: commonEnvironmentColors.tower_stone_highlight, description: "+50 Max Tower Health.", displayCost: 100, isUpgrade: true, isTowerUpgrade: true, flag: 'towerReinforced'},
                { id: 'stakes_upgrade', name: "Barricade Stakes", rarity: "Upgrade", color: bertoldColors.trim, description: "Damages enemies at the wall.", displayCost: 100, isUpgrade: true, isPlayerUpgrade: true, flag: 'hasStakes'},
            ];

            shopUpgrades.forEach(upg => {
                if (!player[upg.flag]) {
                    shopItems.push({...upg, isConsumable: false, isOwned: false});
                } else {
                    shopItems.push({ ...upg, displayCost: "LEARNED", isOwned: true, isConsumable: false });
                }
            });


            rarityOrder.forEach((rarity, index) => {
                const itemsOfThisRarity = crossbowDefinitions.filter(c => c.rarity === rarity);
                const unownedItems = itemsOfThisRarity.filter(c => !ownedCrossbowIds.includes(c.id));
                let itemToShow = null; let isOwned = false; let displayCost = slotCosts[index];
                if (unownedItems.length > 0) { itemToShow = unownedItems[Math.floor(Math.random() * unownedItems.length)]; }
                else if (itemsOfThisRarity.length > 0) { if(player.equippedCrossbow && player.equippedCrossbow.rarity === rarity){ itemToShow = player.equippedCrossbow;} else {itemToShow = itemsOfThisRarity.sort((a,b) => b.damage - a.damage)[0];} isOwned = true; }
                if (itemToShow) { shopItems.push({ ...itemToShow, displayCost: isOwned ? "OWNED" : displayCost, isOwned: isOwned, isUpgrade: false, isConsumable: false }); }
            });

            shopItems.push({ id: 'health_potion', name: "Reinforced Stone Draught", rarity: "Consumable", color: commonEnvironmentColors.potion_green, description: "Restores 25 Tower Health.", displayCost: 75, isConsumable: true, isUpgrade: false, isOwned: false });
            shopItems.push({ id: 'fireball_scroll', name: "Scroll: Fireball", rarity: "Consumable", color: commonEnvironmentColors.potion_red, description: "Damages all enemies (60 Dmg).", displayCost: 75, isConsumable: true, isUpgrade: false, isOwned: false });
            shopItems.push({ id: 'freeze_scroll', name: "Scroll: Rimefrost", rarity: "Consumable", color: commonEnvironmentColors.potion_blue, description: "Freezes enemies for 3s.", displayCost: 75, isConsumable: true, isUpgrade: false, isOwned: false });
            shopItems.push({ id: 'oil_flask', name: "Flask of Alchemist's Fire", rarity: "Consumable", color: commonEnvironmentColors.fire_orange, description: "Creates a pool of fire (15 Dmg/tick).", displayCost: 75, isConsumable: true, isUpgrade: false, isOwned: false});


            if(shopBackgroundDetails.length === 0) generateShopBackgroundDetails();
        }

        function updateScoreDisplay() { scoreDisplay.textContent = `Score: ${score}`; }
        function updateSilverDisplay() { silverDisplay.textContent = `Silver: ${silver}`; }
        function updateAmmoDisplay() { if(player.equippedCrossbow) ammoDisplay.textContent = `Bolts: ${player.currentAmmo}/${player.equippedCrossbow.ammoCapacity}`; }
        function updateHealthDisplay() { healthDisplay.textContent = `Tower: ${towerHealth}/${maxTowerHealth}%`; healthDisplay.style.color = towerHealth<maxTowerHealth*0.3?'#c0392b':towerHealth<maxTowerHealth*0.6?'#f7ca18':'#e0dacd';}
        function updateWaveDisplay() { waveDisplay.textContent = gameState === 'BOSS_WAVE' ? "BOSS WAVE" : `Wave: ${wave}`; }
        function updateConsumableUI() {
            healthPotionCountDisplay.textContent = player.healthPotions;
            fireballScrollCountDisplay.textContent = player.fireballScrolls;
            freezeScrollCountDisplay.textContent = player.freezeScrolls;
            oilFlaskCountDisplay.textContent = player.oilFlasks;
        }
        function showMessage(text, duration=2000, callback) { messageOverlay.textContent=text;messageOverlay.style.display='block';setTimeout(()=>{messageOverlay.style.display='none';if(callback)callback();},duration); }

        function drawSettingsScreen() {
            ctx.fillStyle = commonEnvironmentColors.tower_stone_darker;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.font = `bold ${12 * PIXEL_SCALE}px 'Courier New', monospace`;
            ctx.fillStyle = bertoldColors.trim;
            ctx.textAlign = 'center';
            ctx.fillText("Settings", canvas.width / 2, 50 * PIXEL_SCALE);
        }

        function updateControls() {
            controlsPanel.innerHTML = ''; let button;
            if (gameState === 'START_SCREEN') {
                button = document.createElement('button'); button.textContent = 'Enter Tower'; button.className = 'button pixel-art-font';
                button.onclick = () => { playSound('ui_click'); generateInteriorDetails(); gameState = 'INTRO_CUTSCENE'; cutsceneStage = 0; cutsceneTimer = Date.now(); updateControls(); draw(); let cutsceneLoopId; function animateCutscene(){ if(gameState !== 'INTRO_CUTSCENE' && gameState !== 'VICTORY_CUTSCENE'){ cancelAnimationFrame(cutsceneLoopId); return; } update( (performance.now() - lastTime) / 1000); lastTime = performance.now(); draw(); cutsceneLoopId = requestAnimationFrame(animateCutscene); } lastTime = performance.now(); animateCutscene(); };
                controlsPanel.appendChild(button);

                const settingsButton = document.createElement('button'); settingsButton.textContent = 'Settings'; settingsButton.className = 'button pixel-art-font ml-2';
                settingsButton.onclick = () => { playSound('ui_click'); gameState = 'SETTINGS'; updateControls(); draw(); };
                controlsPanel.appendChild(settingsButton);

            } else if (gameState === 'INTRO_CUTSCENE' || gameState === 'VICTORY_CUTSCENE') {
                button = document.createElement('button'); button.textContent = 'Continue'; button.className = 'button pixel-art-font';
                button.onclick = () => {
                    playSound('ui_click');
                    cutsceneStage++;
                    cutsceneTimer = Date.now();
                    if (gameState === 'INTRO_CUTSCENE' && cutsceneStage >= introCutsceneFrames.length) {
                        gameState = 'TOWER_INTERIOR';
                        cutsceneTextOverlay.style.display = 'none';
                        generateInteriorDetails();
                        updateControls();
                        let interiorAnimId; function animateInteriorLoop() { if (gameState !== 'TOWER_INTERIOR') { cancelAnimationFrame(interiorAnimId); return; } draw(); interiorAnimId = requestAnimationFrame(animateInteriorLoop); } lastTime = performance.now(); animateInteriorLoop();
                    } else if (gameState === 'VICTORY_CUTSCENE' && cutsceneStage >= victoryCutsceneFrames.length) {
                        gameState = 'VICTORY';
                        cutsceneTextOverlay.style.display = 'none';
                        updateControls();
                    }
                    draw(); // Redraw immediately
                };
                controlsPanel.appendChild(button);
            } else if (gameState === 'TOWER_INTERIOR') {
                const prepareButton = document.createElement('button'); prepareButton.textContent = wave > MAX_WAVES ? `Face Jer'Ghuul!` : `Prepare Defenses! (Wave ${wave})`;
                prepareButton.className = 'button pixel-art-font';
                prepareButton.onclick = () => { playSound('ui_click'); if (gameLoopRequestId) cancelAnimationFrame(gameLoopRequestId); startNextWave(); updateControls(); };
                controlsPanel.appendChild(prepareButton);

                const armoryButton = document.createElement('button'); armoryButton.textContent = 'Access Armory'; armoryButton.className = 'button pixel-art-font ml-2';
                armoryButton.onclick = () => { playSound('ui_click'); if (gameLoopRequestId) cancelAnimationFrame(gameLoopRequestId); populateShop(); gameState = 'SHOP'; updateControls(); draw(); };
                controlsPanel.appendChild(armoryButton);

            } else if (gameState === 'SHOP') {
                button = document.createElement('button'); button.textContent = 'Return to Tower';
                button.className = 'button pixel-art-font';
                button.onclick = () => { playSound('ui_click'); tooltipElement.style.display = 'none'; gameState = 'TOWER_INTERIOR'; updateControls(); draw(); let interiorAnimId; function animateInteriorLoop() { if (gameState !== 'TOWER_INTERIOR') { cancelAnimationFrame(interiorAnimId); return; } draw(); interiorAnimId = requestAnimationFrame(animateInteriorLoop); } animateInteriorLoop();};
                controlsPanel.appendChild(button);
            } else if (gameState === 'SETTINGS') {
                const soundBtn = document.createElement('button'); soundBtn.textContent = `Sound: ${soundEnabled ? 'ON' : 'OFF'}`; soundBtn.className = 'settings-button pixel-art-font';
                soundBtn.onclick = () => { soundEnabled = !soundEnabled; playSound('ui_click'); soundBtn.textContent = `Sound: ${soundEnabled ? 'ON' : 'OFF'}`;};
                controlsPanel.appendChild(soundBtn);

                ['Easy', 'Normal', 'Nightmare'].forEach(diff => {
                    const diffBtn = document.createElement('button'); diffBtn.textContent = diff;
                    diffBtn.className = `settings-button pixel-art-font ${difficulty === diff ? 'active' : ''}`;
                    diffBtn.onclick = () => { difficulty = diff; playSound('ui_click'); updateControls(); drawSettingsScreen(); };
                    controlsPanel.appendChild(diffBtn);
                });

                const returnBtn = document.createElement('button'); returnBtn.textContent = 'Return to Main Menu'; returnBtn.className = 'button pixel-art-font mt-4';
                returnBtn.onclick = () => { playSound('ui_click'); gameState = 'START_SCREEN'; updateControls(); draw(); };
                controlsPanel.appendChild(returnBtn);

            } else if (gameState === 'DEFENDING' || gameState === 'BOSS_WAVE') {
                button = document.createElement('button'); button.textContent = 'Retreat to Tower'; button.className = 'button pixel-art-font';
                button.onclick = () => { playSound('ui_click_retreat'); if (gameLoopRequestId) cancelAnimationFrame(gameLoopRequestId); enemies = []; bolts = []; boss = null; activeFireballs=[]; activeOilSpills=[]; enemiesFrozen=false; showMessage("Retreated to the Tower. The Ghouls withdraw... for now.", 2500); gameState = 'TOWER_INTERIOR'; updateControls(); draw(); let interiorAnimId; function animateInteriorLoop() { if (gameState !== 'TOWER_INTERIOR') { cancelAnimationFrame(interiorAnimId); return; } draw(); interiorAnimId = requestAnimationFrame(animateInteriorLoop); } animateInteriorLoop(); };
                controlsPanel.appendChild(button);
            } else if (gameState === 'GAME_OVER' || gameState === 'VICTORY') {
                button = document.createElement('button'); button.textContent = 'Play Again?';
                button.className = 'button pixel-art-font';
                button.onclick = () => { playSound('ui_click'); resetGame(); };
                controlsPanel.appendChild(button);
            }
        }

        function resetGame() {
            score=0; silver=50; towerHealth=100; maxTowerHealth=100; wave=1;
            enemies=[]; bolts=[]; ghoulBolts=[]; boss = null; activeFireballs=[]; activeOilSpills=[]; enemiesFrozen=false;
            ownedCrossbowIds=['peasant'];
            player.hasFlamingArrowsUpgrade = false; player.hasPiercingBoltsUpgrade = false;
            player.hasStakes = false; player.towerReinforced = false;
            player.healthPotions = 0; player.fireballScrolls = 0; player.freezeScrolls = 0; player.oilFlasks = 0;
            equipCrossbow('peasant');
            defenseSceneElementsGenerated = false; shopBackgroundDetails = [];
            updateScoreDisplay(); updateSilverDisplay(); updateHealthDisplay(); updateWaveDisplay(); updateConsumableUI();
            healthDisplay.style.color = '#e0dacd';
            gameState = 'START_SCREEN'; updateControls(); draw();
        }

        // --- Initial Setup & Game Start ---
        function initializeGame() {
            equipCrossbow('peasant');
            updateControls(); // Initial controls for start screen
            updateScoreDisplay();
            updateSilverDisplay();
            updateAmmoDisplay();
            updateHealthDisplay();
            updateWaveDisplay();
            updateConsumableUI();
            draw(); // Initial draw of start screen
        }

        window.onload = () => {
            console.log("Window loaded. Preloading images...");
            messageOverlay.textContent = "Loading assets..."; // Show loading message
            messageOverlay.style.display = 'block';

            preloadAllImages(() => { // This now includes 'start_screen_bg'
                messageOverlay.style.display = 'none'; // Hide loading message
                console.log("Image preloading complete. Initializing game.");
                initializeGame(); // This calls draw(), which will use the preloaded images
            });
        };

        // --- Event Listeners ---
        canvas.addEventListener('mousemove', (event) => {  const rect = canvas.getBoundingClientRect(); mouseX = event.clientX - rect.left; mouseY = event.clientY - rect.top; if (gameState === 'SHOP') { let hoveredItem = null; for (const shopRect of shopItemRects) { if(shopRect.item && mouseX >= shopRect.x && mouseX <= shopRect.x + shopRect.width && mouseY >= shopRect.y && mouseY <= shopRect.y + shopRect.height) { hoveredItem = shopRect.item; break; } } if (hoveredItem) { let costText = hoveredItem.isOwned && !hoveredItem.isConsumable && !(hoveredItem.isUpgrade && !player[hoveredItem.flag]) ? 'OWNED' : (hoveredItem.isUpgrade && player[hoveredItem.flag] ? 'LEARNED' : `${hoveredItem.displayCost} Silver`); tooltipElement.innerHTML = `<strong>${hoveredItem.name}</strong> (<span style="color:${hoveredItem.color};">${hoveredItem.rarity}</span>)<br>Cost: ${costText}<br>${hoveredItem.damage ? `Damage: ${hoveredItem.damage} | Cap: ${hoveredItem.ammoCapacity}<br>Reload: ${hoveredItem.reloadTime.toFixed(1)}s | Bolt Speed: ${hoveredItem.boltSpeed}<br>` : ''}<em>${hoveredItem.description}</em>`;
            let tooltipTop = event.clientY - tooltipElement.offsetHeight / 2;
            let tooltipLeft = event.clientX - tooltipElement.offsetWidth / 2;

            tooltipElement.style.display = 'block';
            const tooltipHeight = tooltipElement.offsetHeight;
            const tooltipWidth = tooltipElement.offsetWidth;

            if (event.clientY + tooltipHeight/2 + 10 > window.innerHeight) {
                tooltipTop = window.innerHeight - tooltipHeight - 10;
            }
            if (tooltipTop < 10) {
                tooltipTop = 10;
            }
            if (event.clientX + tooltipWidth/2 + 10 > window.innerWidth) {
                tooltipLeft = window.innerWidth - tooltipWidth - 10;
            }
            if (tooltipLeft < 10) {
                tooltipLeft = 10;
            }

            tooltipElement.style.left = `${tooltipLeft}px`;
            tooltipElement.style.top = `${tooltipTop}px`;
            } else { tooltipElement.style.display = 'none'; } } else { tooltipElement.style.display = 'none'; } });
        canvas.addEventListener('click', (event) => {
            if (gameState === 'INTRO_CUTSCENE' || gameState === 'VICTORY_CUTSCENE') {
                playSound('ui_click');
                cutsceneStage++;
                cutsceneTimer = Date.now();
                 if (gameState === 'INTRO_CUTSCENE' && cutsceneStage >= introCutsceneFrames.length) {
                    gameState = 'TOWER_INTERIOR';
                    cutsceneTextOverlay.style.display = 'none';
                    generateInteriorDetails();
                    updateControls();
                    let interiorAnimId; function animateInteriorLoop() { if (gameState !== 'TOWER_INTERIOR') { cancelAnimationFrame(interiorAnimId); return; } draw(); interiorAnimId = requestAnimationFrame(animateInteriorLoop); } lastTime = performance.now(); animateInteriorLoop();
                } else if (gameState === 'VICTORY_CUTSCENE' && cutsceneStage >= victoryCutsceneFrames.length) {
                    gameState = 'VICTORY';
                    cutsceneTextOverlay.style.display = 'none';
                    updateControls();
                }
                draw(); // Redraw immediately
                return;
            }

            if (gameState === 'SHOP') { playSound('ui_click_shop'); const rect = canvas.getBoundingClientRect(); const clickX = event.clientX - rect.left; const clickY = event.clientY - rect.top; for (const shopRect of shopItemRects) { if (shopRect.item && clickX >= shopRect.x && clickX <= shopRect.x+shopRect.width && clickY >= shopRect.y && clickY <= shopRect.y+shopRect.height) { const itemToInteract = shopRect.item; if(itemToInteract.isUpgrade){ if(!player[itemToInteract.flag] && silver >= itemToInteract.displayCost){ silver -= itemToInteract.displayCost; player[itemToInteract.flag] = true; if(itemToInteract.id === 'tower_reinforce_1'){ maxTowerHealth += 50; towerHealth +=50; updateHealthDisplay();} playSound('upgrade_purchase'); showMessage(`${itemToInteract.name} Acquired!`, 1500);} else if (player[itemToInteract.flag]) { showMessage("Already Acquired!", 1000); } else { showMessage("Not enough silver!", 1000);}} else if (itemToInteract.isConsumable) { if(silver >= itemToInteract.displayCost){ silver -= itemToInteract.displayCost; playSound('item_purchase'); if(itemToInteract.id === 'health_potion') player.healthPotions++; else if(itemToInteract.id === 'fireball_scroll') player.fireballScrolls++; else if(itemToInteract.id === 'freeze_scroll') player.freezeScrolls++; else if(itemToInteract.id === 'oil_flask') player.oilFlasks++; updateConsumableUI(); showMessage(`Purchased ${itemToInteract.name}!`, 1200);} else {showMessage("Not enough silver!", 1000);}} else if(itemToInteract.isOwned){ if(player.equippedCrossbow.id !== itemToInteract.id){ equipCrossbow(itemToInteract.id); playSound('equip_item'); showMessage(`Equipped ${itemToInteract.name}!`,1200);}} else if(silver >= itemToInteract.displayCost){ silver -= itemToInteract.displayCost; ownedCrossbowIds.push(itemToInteract.id); equipCrossbow(itemToInteract.id); updateSilverDisplay(); playSound('item_purchase'); showMessage(`Purchased ${itemToInteract.name}!`,1200);} else{ showMessage("Not enough silver!",1000); } populateShop(); drawShopScreen(); break; } } } else if (gameState === 'DEFENDING' || gameState === 'BOSS_WAVE') { if(!player.isReloading) {if(player.currentAmmo > 0){ shootBolt(); player.currentAmmo--; updateAmmoDisplay(); } else { showMessage("Empty! Auto-Reloading...",1000); startReload();} } } });
        document.addEventListener('keydown', (event) => {
            if (gameState==='DEFENDING' || gameState === 'BOSS_WAVE') {
                if (event.key.toLowerCase()==='r' && !player.isReloading && player.currentAmmo < player.equippedCrossbow.ammoCapacity) startReload();
                else if (event.key.toLowerCase()==='h' && player.healthPotions > 0 && towerHealth < maxTowerHealth) { player.healthPotions--; towerHealth = Math.min(maxTowerHealth, towerHealth + Math.floor(maxTowerHealth * 0.25)); updateHealthDisplay(); updateConsumableUI(); playSound('potion_use'); showMessage("Tower Mended!", 1000);}
                else if (event.key.toLowerCase()==='f' && player.fireballScrolls > 0) {
                    player.fireballScrolls--; updateConsumableUI(); playSound('fireball_cast'); showMessage("FIREBALL!", 800);
                    activeFireballs.push({x: mouseX, y: mouseY, radius: 10*PIXEL_SCALE, duration: 1.0, expansionRate: 80*PIXEL_SCALE});
                    const targets = gameState === 'BOSS_WAVE' && boss ? [boss] : enemies;
                    targets.forEach(enemy => { if(Math.hypot(enemy.x + enemy.width/2 - mouseX, enemy.y + enemy.height/2 - mouseY) < 80*PIXEL_SCALE) enemy.health -= 60; enemy.hitByFireballThisFrame = false;});
                    setTimeout(() => { if(boss && boss.health <=0) {boss = null; gameState = 'VICTORY_CUTSCENE'; cutsceneStage = 0; cutsceneTimer = Date.now(); playSound('boss_death'); updateControls(); draw();} enemies = enemies.filter(e => e.health > 0);}, 200);
                }
                else if (event.key.toLowerCase()==='g' && player.freezeScrolls > 0 && !enemiesFrozen) { player.freezeScrolls--; enemiesFrozen = true; freezeTimer = 3.0; updateConsumableUI(); playSound('freeze_cast'); showMessage("RIMEFORST!", 1000);}
                else if (event.key.toLowerCase()==='o' && player.oilFlasks > 0) {
                    player.oilFlasks--; updateConsumableUI(); playSound('oil_spill_sound'); showMessage("Alchemist's Fire!", 800);
                    activeOilSpills.push({x: canvas.width/2 - 20*PIXEL_SCALE, y: player.y + 10*PIXEL_SCALE, width: 40*PIXEL_SCALE, height: 15*PIXEL_SCALE, duration: 5.0, startTime: Date.now()});
                }
            }
        });

    </script>
</body>
</html>
